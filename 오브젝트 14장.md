재사용 가능한 설계를 하는 법
- 객체지향 패러다임의 장점은 설계를 재사용할 수 있다는 것
- 재사용을 위해서는 객체들의 협력 방식을 일관성 있게 만들어야 함
  
일관성있는 설게의 장점
- 일관성은 설계에 드는 비용을 감소시킴
- 과거의 해결 방법을 반복적으로 사용해 유사한 기능을 구현하는데 드는 시간과 노력을 줄일 수 있기 때문
- 일관성있는 설계는 코드의 가독성을 높임


핸드폰 과금 시스템 변경하기
![[Pasted image 20240405231854.png]]

고정요금 방식
- 일정 시간 단위로 동일한 요금을 부여

시간대별 방식
- 하루 24시간 중 특정 시간 구간을 나누어 구간별로 서로 다른 요금을 부과

요일별 방식
- 요일별로 요금을 차등 부과

구간별 방식
- 전체 통화 시간을 일정 통화 시간에 따라 나눠서 각 구간별로 요금을 차등 부과


11장의 부가 정책과 가능한 조합을 표시한다면... ?

![[Pasted image 20240405232023.png]]


추가된 요금제에 맞는 클래스 구조
![[Pasted image 20240405232130.png]]


고정요금 방식 구현하기
```java
public class FixedFeedPolicy extends BasicRatePolicy {
	private Money amount;
	private Duration seconds;

	# 고정요금 방식
	public FixedFeelPolicy(Money amount, Duration seconds) {
		this.amount = amount;
		this.seconds = seconds;
	}

	@Override
	protected Money calculateCallFee(Call call) {
		# 고정 요금 방식의 요금 계산 방식
		return amount.times(call.getDuration().getSeconds() / seconds.getSeconds());
	}
}
```


시간대별 방식 구현하기
- 통화 기간을 정해진 시간대별로 나눈 후 각 시간대별로 서로 다른 계산 규칙을 적용함
![[Pasted image 20240405232525.png]]
- 통화가 여러 날에 걸쳐 이뤄질 수 있어서 시작일자와 종료일자를 함께 고려함

```java
public class DateTimeInterval {
	private LocalDateTime from;
	private LocalDateTime to;

	# 객체 생성을 위한 정적 메서드들
	public static DateTimeInterval of(LocalDateTime from, LocalDateTime to) {
		return new DateTimeInterval(from, to);
	}

	public static DateTimeInterval toMidnight(LocalDateTime from) {
		return new DateTimeInterval(
			from,
			LocalDateTime.of(from.toLocalDate(), LocalTime.of(23, 59, 59, 999_999_999))
		)
	}

	public static DateTimeInterval fromMidnight(LocalDateTime to) {
		return new DateTimeInterval(
			LocalDateTime.of(date, LocalTime.of(0, 0)),
			to);
	}

	public static DateTimeInterval during(LocalDateTime date) {
		return new DateTimeInterval(
			LocalDateTime.of(date, LocalTime.of(0, 0)),
			LocalDateTime.of(from.toLocalDate(), LocalTime.of(23, 59, 59, 999_999_999))
		)
	}

	private DateTimeInterval(LocalDateTime from, LocalDateTime to) {
		this.from = from;
		this.to = to;
	}

	public Duration duration() {
		return Duration.between(from, to);
	}

	public LocalDateTime getFrom() {
		return from;
	}

	public LocalDateTime getTo() {
		return to;
	}
}
```
- DateTimeInterval 이라는 타입을 사용함으로 'from'과 'to'를 하나의 인스턴스 변수로 묶을 수 있음
```java
# 기존 버전
public class Call {
	private LocalDateTime from;
	private LocalDateTime to;
}

# 수정 버전
public class Call {
	private DateTimeInterval interval;

	public Call(LocalDateTime from, LocalDateTime to) {
		this.interval = DateTimeInterval.of(from, to);
	}

	public Duration getDuration() {
		return interval.duration();
	}

	public LocalDateTime getFrom() {
		return interval.getFrom();
	}

	public LocalDateTime getTo() {
		return interval.getTo();
	}

	public DateTimeInterval getInterval() {
		return interval;
	}
}
```

요구사항
- 통화 기간을 일자별로 분리한다.
- 일자별로 분리된 기간을 다시 시간대별 규칙에 따라 분리한 후 각 기간에 대해 요금을 계산한다.


두 작업은 어떤 객체의 책임인가?
- 책임은 필요한 정보를 가장 잘 알고 있는 정보 전문가에게 할당하는 것
- 통화 기간을 일자 단위로 나누는 정보 전문가는 ? 'Call'
- 하지만 'Call'은 기간에 대한 정보 전문가는 아니다.
- 기간을 처리하는 전문가는 ? 'DateTimeInterval'
- 따라서, 기간을 일자 단위로 나누는 책임은 'DateTimeInterval'에게 할당하고, 'Call'이 'DateTimeInterval'에게 분할을 요청하도록 협력을 설계하는 것이 적절
- 두 번째 작업인 시간대별로 분할하는 작업의 전문가는 누구인가?
- 시간대별 기준을 잘 알고 있는 것은 요금 정책이며, 새로운 클래스(TimeOfDayDiscountPolicy)로 구현함

협력 방법
- TimeOfDayDiscountPolicy는 통화 기간을 알고 있는 Call에게 일자별로 통화 기간을 분리할 것을 요청
- Call은 DateTimeInterval에게 이 작업을 위임함
- DateTimeInterval은 기간을 일자 단위로 분할한 후 분할된 목록을 반화함
- Call은 반환된 목록을 그대로 TimeOfDayDiscountPolicy에게 전달
![[Pasted image 20240405234518.png]]


예를 들어?
- 1월 1일 10시부터 1월 3일 15시까지 3일에 걸쳐 통화를 했다면?
- 대략 다음과 같은 형태로 데이터가 구분됨
![[Pasted image 20240405234813.png]]
- 이 구현을 위한 클래스(TimeOfDayDiscountPolicy)에서 중요한 것은 시간에 따라 서로 다른 요금 규칙을 정의하는 방법을 결정하는 것
- 하나의 통화 시간을 구성하는 데는 '시작 시간', '종료 시간', '단위 시간', '단위 요금'이 필요
- 단위 시간은 요금을 부과할 시간의 단위(예시: 10초 당 18원)
- 시간대별 방식은 하나 이상의 시간대로 구성되기 때문에 이 4가지 요소가 하나 이상 존재해야 함으로 List로 구성함
```java
public class TimeOfDayDiscountPolicy extends BasicRatePolicy {
	private List<LocalTime> starts = new ArrayList<>();
	private List<LocalTime> ends = new ArrayList<>();
	private List<Duration> durations = new ArrayList<>();
	private List<Money> amounts = new ArrayList<>();
}
```

List가 구성되는 방식
- 0시부터 19시까지는 10초당 18원의 요금
- 19시부터 24시까지는 10초당 15원의 요금
![[Pasted image 20240405235329.png]]

전체 코드
```java
public class TimeOfDayDiscountPolicy extends BasicRatePolicy {
	private List<LocalTime> starts = new ArrayList<>();
	private List<LocalTime> ends = new ArrayList<>();
	private List<Duration> durations = new ArrayList<>();
	private List<Money> amounts = new ArrayList<>();

	@Override
	proctected Money calculateCallFee(Call call) {
		# 요금 계산 메서드
		Money result = Money.ZERO;
		for(DateTimeInterval interval : call.splitByDay()) {
			for(int loop=0; loop < starts.size(); loop++) {
				result.plus(amount.get(loop).times(
					Duration.between(from(interval, starts.get(loop)), to(interval, ends.get(loop))).getSeconds() / duration.get(loop).getSeconds()));
				))
			}
		}

	retunr result;
	}

	private LocalTime from(DateTimeInterval interval, LocalTime from) {
		return interval.getFrom().toLocalTime().isBefrom(from) ?
			from :
			interval.getFrom().toLocalTime();
	}

	private LocalTime to(DateTimeInterval interval, LocalTime to) {
		return interval.getTo().toLocalTime().isAfter(to) ?
			to :
			interval.getTo().toLocalTime();
	}
}
```
- Call의 splitByDay 메서드는 DateTimeInterval에 요청을 전달 후 응답을 반환하는 위임 메서드
```java
public class Call {
	public List<DateTimeInterval> splitByDay() {
		return interval.splitByDay();
	}
}
```


비슷한 메커니즘으로..
- 요일별 방식과 구현별 방식도 구현
- 책에서 사용한 요일별 방식의 코드 예시)
```java
public class DayOfWeekDiscountRule {
	...(생략)
	# 시간별 방식(list로 규칙 관리)과 달리 'DayOfWeekDiscountRule'이라는 별도의 클래스로 규칙을 구성
}
```
- 이런 메커니즘으로 구현을 하는 경우의 문제는?
	- 비슷한 문제를 해결하나 설계에 일관성이 없음
	- 이 클래스들은 기본 정책을 구현한다는 공통 목점이 있으나 정책을 구현하는 방식이 완전히 다름
	- 즉, 개념적으로는 연관돼 있지만 구현 방식에 있어서 완전히 제각각임


비일관성의 문제는..?
- 새로운 구현을 추가해야 할 때
	- 구간별 방식을 추가해야 한다면?
	- 우선, BasicRatePolicy를 상속받는 클래스를 추가함
	- 그리고 'calculateCallFee' 메서드를 오버라이딩 하고 메서드를 구현함
	- 시간별과 요일별 클래스는 여러 규칙(일자별, 시간별 혹은 단위시간 별 요금 규칙 등)을 공유하지만 구현 방식이 완전 다름
	- 여기에 고정요금 방식을 추가한다면, 고정 요금 방식은 규칙이 단 하나 존재하기 때문에 더더욱 문제가 복잡해진다.
	- 결국, 세 가지 기본 정책에 대해 세 가지 서로 다른 구현이 존재하는 상황
	- 때문에 '구간별' 방식이라는 새로운 클래스를 추가해야할 때 설계를 일관성있게 가져가기 어렵고 전혀 다른 구현을 하게 되어 '네 가지 기본 정책'에 '네 가지 구현'이 발생할 확률이 높음
- 기존의 구현을 이해해야 할 때
	- 현재 구조에서는 고정 요금 클래스 구현을 이해한다고 해서, 시간별 요금 클래스를 이해하는데 도움이 전혀 되지 않는다.



설계에 일관성을 부여하자

협력을 일관성 있게 만들기 위한 기본 지침
- 변하는 개념을 변하지 않는 개념으로부터 분리
- 변하는 개념을 캡슐화

```
애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시킨다.
이것은 여러 설계 원칙 중에서 첫 번째 원칙이다. 즉, 코드에서 새로운 요구사항 있을 때마다 바뀌는 부분이 있다면 그 행동을 바뀌지 않는 다른 부분으로부터 골라내서 분리해야 한다는 것을 알 수 있다. 이 원칙은 다음과 같은 식으로 생각할 수 있다.
"바뀌는 부분을 따로 뽑아서 캡슐화한다. 그렇게 하면 나중에 바뀌지 않는 부분에는 영향을 미치지 않은 채로 그 부분만 고치거나 확장할 수 있다."
```


조건 로직 대 객체 탐색
예시) ReservationAgency
```java
public class ReservationAgency {
	public Reservation reserve(Screening screening, Customer customer, int audienceCount) {
		for(DiscountCondition condition : movie.getDiscountConditions()) {
			if (condition.getType() == DiscountConditionType.PERIOD) {
				//기간 조회인 경우
			} else {
				//회차 조건인 경우
			}
		}
		if (discountable) {
			switch(movie.getMovieType()) {
				case AMOUNT_DISCOUNT:
					//금액 할인 정책인 경우
				case PERCENT_DISCOUNT:
					//비율 할인 정책인 경우
				case NONE_DISCOUNT;
					//할인 정책이 없는 경우
			}
		} else {
			//할인 정책이 없는 경우
		}
	}
}
```
- 위 코드에는 두 개의 조건 로직이 존재
	- 하나는 할인 조건의 종류를 결정하는 부분
	- 다른 하나는 할인 정책을 결정하는 부분
- 이 설계가 나쁜 이유는?
	- 변경의 주기가 서로 다른 코드가 한 클래스 안에 뭉쳐있기 때문
	- 또한 새로운 할인 정책이나 할인 조건을 추가하기 위해서는 기존 코드의 내부를 수정해야 해서 오류 발생 확률이 높아짐
	- 


객체지향에서 변경을 다루는 법
- 전통적인 방법은 조건 로직을 객체 사이의 이동으로 바꾸는 것
```java
public clas Movie {
	private DiscountPolicy discountPolicy;

	public Money calculateMovieFee(Screening screening) {
		return fee.minus(discountPolicy.calculateDiscountAmount(screening));
	}
}
```
- movie는 현재의 할인 정책이 어떤 종류인지 확인하지 않고, 단순히 현재 할인 정책을 나타내는 'discountPolicy'에 필요한 메시지를 전송할 뿐이다.
- 즉, 할인 정책의 종류를 if문이 아닌 'discountPolicy'로 객체 이동을 한 것
- 다형성은 이런 조건 로직을 객체 사이의 이동으로 바꾸기 위해 객체지향이 제공하는 설계 기법
- 객체지향적인 코드는 조건을 판단하지 않는다. 단지 다음 객체로 이동할 뿐이다.

클래스 분리의 기준
- 조건 로직을 객체 사이의 이동으로 대체하기 위해선 커다란 클래스(추상 클래스)를 더 작은 클래스(구체 클래스)로 분리해야 한다.
- 가장 중요한 분리 기준은 변경의 이유와 주기다.
- 클래스는 명확히 단 하나의 이유에 의해서만 변경돼야 하고 클래스 안의 모든 코드는 함께 변경돼야 한다