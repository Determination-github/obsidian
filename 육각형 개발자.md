# 제목
---

날짜: 2023-11-08
태그:
메모:

코드 이해 도구
- 시각화
- 코드 출력
- 스크래치 리팩터링

코드 시각화
- 코드를 분석하고 결과를 그림으로 그림
- 가급적 UML을 사용
- UML 중 액티비티 다이어그램은 실행 흐름 분석에 도움이 됨

액티비티 다이어그램
- 코드 한 줄마다 다이어그램을 추가하면 복잡하고 어려워짐
- 여러 코드가 하나의 목적으로 사용되면 논리적인 단위로 묶어 표시


코드출력
- 코드를 A3와 같은 용지로 뽑아 한 눈에 볼 수 있게 하는 것

스크래치 리팩터링
- 코드 분석을 목적으로 하는 리팩터링
- 리팩터링을 하면 변수 이름 변경, 메서드 추출, 클래스 추출, 파라미터 타입 변경과 같은 수정을 하게 된다
- 스크래치 리팩터링은 코드 개선이 아닌 코드 이해가 목적이므로 리팩터링한 결과는 반영하지 않고 원래대로 되돌린다

이해하기 좋은 코드 작성법 추천 책
- 켄트 벡의 구현 패턴
- 클린 코드

코드 작성법 몇가지 팁
이름
- 적절한 변수명을 작성해야 함
- 클래스에 포함된 필드라면 클래스 이름을 중복해서 작성할 필요는 없음
중첩 if 최소화
- 복잡한 if-else는 코드분석을 어렵게 함
- if문을 역으로 활용해, 조건에 따라 early return하게 하는 방식도 있음
변수 줄이기
- 변수의 사용범위가 넓거나 변수 개수가 많을 때, 변수 변경이 빈번하거나 변수 용도가 중간에 바뀔 때 코드 분석이 어려움
- 변수 선언 상황
  - 사용되기 직전에 정의
  - 짧은 루프 블록 안으로 한정
  - 짧은 if-else 블록 안으로 한정
  - 짧은 메서드로 한정

한 메서드에 모든 구현을 담지 않는다
- 코드를 길지 않게 작성한다
- 길지 않은 코드는 결국 추상화 수준을 맞추는 것과 연결됨

> 추상화 수준?
> 코드를 읽으면서 파악할 수 있는 정보와 수준

들쑥날쑥한 추상화 수준은 코드를 읽기 어렵게 함
- 한 메서드 내에서 코드가 표현하는 추상화 수준을 맞춰야 함


응집도(Cohesion)
- 모듈 안에 있는 요소가 함께 모여 있는 정도
- 한 모듈의 파트가 동일한 모듈 안에 얼마나 포함괴어 있는지
- 즉, 관련 코드가 한곳에 모여있으면 응집도가 높다. 반대로 관련 코드가 여러 곳애 분산되어 있으면 응집도가 낮다
- 예시)
- MemberService가 회원 가입, 회원 정보 변경, 암호 변경, 회원 탈퇴 등의 기능을 구현하면 서로 목적이 다른 코드가 한 클래스에 있어서 응집도가 떨어짐
- 응집도를 높이려면 회원 가입을 위한 클래스, 회원 정보 변경을 위한 클래스, 암호 변경을 위한 클래스, 회원 탈퇴를 위한 클래스로 분리해야 함


응집도를 높여야 하는 이유?
- 응집도가 높으면 관련 코드가 한곳에 모여 있고 관련되지 않은 코드는 포함하지 않음
- 역할에 따라 클래스가 분리되면서 자연스럽게 클래스 길이가 줄어듬
- 메서드 단위로 작성되기 때문에 가독성이 좋아짐
- 따라서 코드 분석 시간을 줄여줌
- 응집도가 높아지면 기능을 변경할 때 수정 범위도 줄어듦
- 응집도가 높아진다는 것은 단일 책임 원칙을 따를 가능성이 높아진다는 것

객체지향과 캡슐화
- 캡슐화는 데이터와 함수를 한곳에 모음
- 캡슐화는 응집도를 높이는 하나의 방법
- 캡슐화는 데이터에 대한 직접 접근을 최소화해서 구현을 감추고 외부에 기능을 제공
- 이렇게 하면 구현을 변경해야 할 때 수정 범위가 캡슐화한 객체로 좁여짐
- 116p

결합도
- 소프트웨어 모듈이 서로 의존하는 정도
- 두 모듈이 얼마나 밀접하게 연결되어 있는지 모듈 간 관계 정도를 나타낸다.
- 한 요소를 수정할 때 다른 요소도 함께 수정해야 하면 두 요소 간 결합도가 높다고 표현

결합도와 응집도
- 응집도가 높다고 해서 반드시 결합도가 낮아지는 것은 아니다.
- 응집도를 높이려면 코드를 역할에 따라 분리해야 한다.
- 그러나 분리된 요소 간에 의존이 발생하게 되고, 서로 의존하는 정도가 올라갈수록 결합도가 증가
- 응집도를 높이고 결합도를 낮추려면 구성 요소 간 상호 작용을 최소화해야 한다.
- 구성 요소 간 상호 작용을 최소화하려면 구현에 대한 의존을 줄이는 것이 중요하다.
- 캡슐화는 구현을 감춤으로써 두 구성 요소 간의 상호 작용을 줄여주어 응집도를 높이는 동시에 결합도를 낮춘다.

추상화 타입과 결합도
예시:
```Java
public class MemberRegister {
	private JdbcTemplate jdbcTemplate;
	... 생략

	public void register(RegisterRequest req) {
		validate(req);
		Member m = createPendingMember(req);
		saveMember(m);
		sendNotiSms(m);
	}
	...
	private void sendNotiSms(Member m) {
		String content = "...생략";
		jdbcTemplate.update(
			"insert into SMS_SEND (PHONE, CONTENT) values (?,?)",
			m.getPhone(), content);
		)
	}
}
```
- 위 코드는 구현에 지나치게 의존함
- 추상화로 이런 강결합을 낮출 수 있다.
- 예시:
```java
public class MemberRegister {
	private Notifier notifier; //구현이 아닌 추상화 타입에 의존
	... 생략

	public MemberRegister(Notifier notifier, ...다른 파라미터 생략) {
		this.notifier = notifier;
		...생략
	}

	public void register(RegisterRequest req) {
		validate(req);
		Member m = createPendingMember(req);
		saveMember(m);
		notifyTo(m);
	}
	...
	private void sendNotiSms(Member m) {
		notifier.notifyTo(m);
	}
}
```
- Notifier의 실제 구현체는 MemberRegister 객체를 생성할 때 전달

이벤트와 결합도
- 결합도를 낮추는 또 다른 방법은 이벤트를 사용하는 것
- 이벤트는 발생한 어떤 사건을 의미

결합 유형
공통 결합
- 여러 모듈이 동일한 글로벌 데이터에 접근할 때 발생
- 여러 기능이 글로벌 데이터에 직접 접근하기 때문에 글로벌 데이터에서 변경이 발생하면 예측하기 힘든 문제가 생길 수 있다.

제어 결합
- 한 모듈이 다른 모듈의 흐름을 제어할 때 발생하는 결합
- 무엇을 할지를 전달하는 형태로 흐름을 제어하는데 보통 파라미터를 사용해서 정보를 전달
- 내부 동작 방시을 외부에 노출해서 결합도를 높인다.

하위 클래스 결합
- 상위 클래스 간의 관계를 설명
- 하위 클래스가 상위 클래스에 의존하고 상위 클래스는 하위 클래스에 의존하지 않는다.
- 하지만 상위 클래스 기능을 사용하는 하위 클래스가 많을수록 상위 클래스를 수정하기 어려워진다.

> 상속보다는 조립(Composition over inheritance) 원칙
> 상속을 생각하기 전에 조립을 먼저 고려. 상속은 두 요소 간 강한 결합을 발생시키는 데 조립을 사용하면 상속에 비해 결합도를 낮출 수 있다.


시간적 결합
- 함께 실행해야 하므로 두 기능을 한 모듈에 묶을 때 발생
- 이런 형태의 결합은 추상화나 이벤트 같은 방법으로 결합을 낮출 수 있다.
- 지켜야 하는 실행 순서도 시간적 결합에 해당한다.

논리 결합 또는 변경 결합
- 두 모듈 간의 변경 패턴이 존재할 때 발생
- 만약 모듈, 시스템 데이터를 변경할 때 다른 모듈, 시스템 데이터도 함께 변경해야 한다면 논리 결합이 발생



리팩터링
미사용 코드 삭제
- 사용하지 않는 파라미터, 메서드, 클래스 들은 모두 삭제 대상
- 메서드나 클래스 전체를 주석 처리하고 일정 기간이 지난 뒤에 삭제한다.
- 메서드와 클래스를 삭제할 때는 리플렉션으로 접근하는 코드인지 확인해 봐야 함

매직 넘버
- 그 값이 무엇을 의미하는지 유추하기 어려운 숫자
- 매직 넘버는 상수나 열거 타입을 사용해서 이름을 부여하는 방법으로 특정 값의 의미를 드러낸다.

이름 변경
- 이름은 짧을 수록 좋지만 이름을 짧게 만들어 너무 많은 의미가 생략된다면 차라리 긴 이름이 낫다.

메서드 추출
- 논리적으로 하나의 작업을 수행하는 코드를 대상으로 실행한다.
- 추출한 메서드에 알맞은 이름을 부여함으로써 가독성이 좋아지고, 관련 코드가 한 메서드에 모이면서 코드도 더 응집된다.

클래스 추출
- 메서드 추출 과정에서 파라미터로 값을 전달하는 과정이 복잡할 때 메서드 추출 대신 클래스 추출을 고려해 볼 수 있다.

쿨래스 분리
- 한 클래스에 많은 기능이 모여 있으면 각 기능을 별도 클래스로 분리한다.

메서드 분리
- 메서드가 완전히 구분되는 기능을 구현하고 있는 경우 각 기능을 구현하는 메서드를 따로 만들고 분리해서 기능별로 응집도를 높일 수 있다.
- 메서드를 분리할 대는 다음 순서대로 진행
	1. 두 기능 중 한 기능을 위한 메서드를 추가한다. 이 메서드는 내부에서 기존 메서드를 호출한다.
	2. 기존 메서드를 호출하는 코드가 새 메서드를 호출하도록 변경한다.
	3. 기존 메서드의 코드를 새 메서드로 이동한다.
	4. 기존 메서드 이름을 변경한다.
	5. 코드를 정리한다.

파라미터값 정리
- 메서드에서 사용하지 않는 파라미터 데이터는 제거해야 한다.
- 사용하지 않는 파라미터값은 코드 분석을 어렵게 만들기 때문이다.
- 파라미터의 특정 값이 실제로 사용되는지 확인하려면 메서드 자체와 그 메서드가 같은 파라미터를 사용해서 호출하는 메서드까지 흐름에 따라 모든 코드를 뒤져야 한다.

for에서 하는 2가지 일 분리
- 하나의 for문에서 여러 가지 작업을 실행하면 서로 다른 목적을 가진 코드가 뒤섞일 수 있다.
- 서로 다른 목적의 코드가 뒤섞이면 코드 복잡도가 증가하고 코드를 이해하기 어려워진다.
- 루프를 여러 번 돌리면 성능이 느려지지 않는가?
	- 대부분 성능에 문제가 없다.
	- 복잡한 코드보다 이해하기 좋은 코드가 주는 이점이 더 크다




출처:
연결문서
