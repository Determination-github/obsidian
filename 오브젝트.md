# 오브젝트 정리_01장
---

날짜: 2024-01-11
태그: #오브젝트
메모:

> 패러다임이란?
> 모델(model), 패턴(pattern), 또는 전형적인 예(example)를 의미하는 그리스어인 '파라데이그마(paradeigma)'에서 유래, 패러다임은 하나의 예를 복사하도록 허용


패러다임 전환(Paradigm Shift)
- 우주를 보는 관점이 천동설에서 지동설로 변화한 사건이 패러다임 전환이 대표 예
- 오브젝트 책에서는  '절차형 패러다임'에서 '객체지향 패러다임'으로 변화를 의미

프로그래밍 패러다임이 필요한 이유
- 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유할 수 있게 함으로써 불필요한 부분에 대한 의견 충돌을 방지
- 프로그래밍 패러다임을 교육시킴으로써 동일한 규칙과 방법을 공유하는 개발자로 성장할 수 있도록 준비

다중패러다임 언어(Multiparadigm Language)
- 하나 이상의 패러다임을 수용하는 언어
- 함수형 패러다임과 객체지향 패러다임을 접목한 스칼라(Scala) 등이 예시


---

티켓 판매 애플리케이션 구현하기

요구사항
- 추첨을 통해 선정된 관람객에게 공연을 무료로 관람할 수 있는 초대장을 발송
- 초대되지 못한 관람객을 티켓을 구매해야만 입장할 수 있음
- 따라서, 관람객을 입장시키기 전에 이벤트 당첨 여부를 확인해야 하고, 이벤트 당첨자가 아닌 경우 티켓을 판매 후 입장시켜야 함

Invitation Class
```Java
public class Invitation {
	private LocalDateTime when;
}
```
- 공연을 관람할 수 있는 초대일자(when)를 인스턴스 변수로 포함하는 간단한 클래스

Ticket Class
```Java
public class Ticket {  
    private Long fee;  
      
    public Long getFee() {  
        return fee;  
    }  
}
```
- 공연을 관람하기 원하는 모든 사람들은 티켓을 소지하고 있어야만 한다.

요구사항 #2
- 이벤트 당첨자는 티켓으로 교환할 초대장을 가지고 있고, 이벤트에 당첨되지 않은 관람객은 티켓을 구매할 현금을 보유하고 있다.
- 따라서 관람객이 가지고 올 수 있는 소지품은 초대장, 현금, 티켓 세 가지뿐이다.
- 관람객은 소지품을 보관할 용도로 가방을 들고 올 수 있다.

Bag Class
```Java
public class Bag {  
    private Long amount;  
    private Invitation invitation;  
    private Ticket ticket;  
      
    public boolean hasInvitation() {  
        return invitation != null;  
    }  
      
    public boolean hasTicket() {  
        return ticket != null;  
    }  
      
    public void setTicket(Ticket ticket) {  
        this.ticket = ticket;  
    }  
      
    public void minusAmount(Long amount) {  
        this.amount -= amount;  
    }  
      
    public void plusAmount(Long amount) {  
        this.amount += amount;  
    }  
}
```
- 관람객이 소지품을 보관할 Bag 클래스
- 초대장(Invitation), 티켓(Ticket), 현금(Amount)을 인스턴스 변수로 포함
- 초대장의 보유 여부를 판단하는 `hasInvitation` 메서드와 티켓의 소유 여부를 판단하는 `hasTicket` 메서드, 현금을 증가시키거나 감소시키는 `plusAmount`와 `minusAmount` 메서드, 초대장을 티켓으로 교환하는 `setTicket` 메서드를 구현


요구사항 #3
- 이벤트에 당첨된 관람객의 가방 안에는 현금과 초대장이 들어있지만 이벤트에 당첨되지 않은 과람객의 가방 안에는 초대장이 들어있지 않을 것이다.
- 따라서 Bag 인스턴스의 상태는 현금과 초대장을 함께 보관하거나, 초대장 없이 현금만 보관하는 두 가지 중 하나일 것이다.
- Bag 인스턴스를 생성하는 시점에 이 제약을 강제할 수 있도록 생성자를 추가

Bag Class
```Java
public class Bag {
	public  Bag(Long amount) {  
	    this(null, amount);  
	}  
	  
	public Bag(Invitation invitation, Long amount) {  
	    this.invitation = invitation;  
	    this.amount = amount;  
	}

	...(생략)
}
```

Audience Class
```Java
public class Audience {  
    private Bag bag;  
  
    public Audience(Bag bag) {  
        this.bag = bag;  
    }  
  
    public Bag getBag() {  
        return bag;  
    }  
}
```
- 관람객이라는 개념을 구현
- 관람객을 소지품을 보관하기 위해 가방을 소지할 수 있음

요구사항 #4
- 관람객이 소극장에 입장하기 위해서는 매표소에서 초대장을 티켓으로 교환하거나 구매해야 함
- 따라서 매표소에는 관람객에게 판매할 티켓과 티켓의 판매 금액이 보관
- 매표소를 구현하기 위해 `TicketOffice` 클래스를 추가
- `TicketOffice`는 판매하거나 교환해 줄 티켓의 목록(tickets)과 판매 금액(amount)을 인스턴스 변수로 포함
- 티켓을 판매하는 `getTicket` 메서드는 편의를 위해 tickets 컬렉션에서 맨 첫 번째 위치에 저장된 Ticket을 반환하는 것으로 구현
- 또한 판매금액을 더하거나 차감하는 `plusAmount`와 `minusAmount` 메서드도 구현

TicketOffice Class
```Java
public class TicketOffice {  
      
    private Long amount;  
    private List<Ticket> tickets = new ArrayList<>();  
      
    public TicketOffice(Long amount, Ticket ... tickets) {  
        this.amount = amount;  
        this.tickets.addAll(Arrays.asList(tickets));  
    }  
      
    public Ticket getTicket() {  
        return tickets.remove(0);  
    }  
      
    public void minusAmount(Long amount) {  
        this.amount -= amount;  
    }  
      
    public void plusAmount(Long amount) {  
        this.amount += amount;  
    }  
}
```


TicketSeller Class
```java
public class TicketSeller {  
      
    private TicketOffice ticketOffice;  
      
    public TicketSeller(TicketOffice ticketOffice) {  
        this.ticketOffice = ticketOffice;  
    }  
      
    public TicketOffice getTicketOffice() {  
        return ticketOffice;  
    }  
}
```
- 판매원 클래스
- 매표소에서 초대장을 티켓으로 교환해 주거나 티켓을 판매하는 역할을 수행
- 판매원을 구현한 `TicketSeller` 클래스는 자신이 일하는 매표소(TicketOffice)를 알아야 함

애플리케이션 핵심 클래스 정리
![[오브젝트_1.1.png]]
- 애플리케이션 핵심 클래스 중간정리

요구사항 #5
- 소극장을 구현하는 클래스는 `Theater`
- Theater 클래스가 관람객을 맞이할 수 있도록 enter 메서드를 구현
```java
public class Theater {  
    private TicketSeller ticketSeller;  
  
    public Theater(TicketSeller ticketSeller) {  
        this.ticketSeller = ticketSeller;  
    }  
  
    public void enter(Audience audience) {  
        if (audience.getBag().hasInvitation()) {  
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();  
            audience.getBag().setTicket(ticket);  
        } else {  
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();  
            audience.getBag().minusAmount(ticket.getFee());  
            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());  
            audience.getBag().setTicket(ticket);  
        }  
    }  
}
```

위 요구사항을 구현한 코드들의 문제점

모듈의 세 가지 목적(클린 소프트웨어: 애잘일 원칙과 패턴, 그리고 실천 방법, 로버트 마틴)
> 모든 소프트웨어 모듈에는 세 가지 목적이 있다.
> 첫 번째: 실행 중에 제대로 동작하는 것
> 두 번째: 변경을 위해 존재하는 것, 대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 함, 변경하기 어려운 모듈은 제대로 동작하더라도 개선해야 함
> 세 번째: 모듈은 코드를 읽는 사람과 의사소통하는 것, 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 함


예상을 빗나가는 코드

Theater 클래스의 enter 메서드가 수행하는 일을 말로 풀었을 때
> 소극장은 관람객의 가방을 열어 그 안에 초대장이 있는지 확인, 가방에 초대장이 있으면 판매원은 매표소에 있는 티켓을 관람객의 가방으로 옮긴다. 가방 안에 초대장이 없으면 관람객의 가방에서 티켓 금액만큼의 현금을 꺼내 매표소에 적립 후 티켓을 관람객의 가방에 옮긴다.
- 위의 예시에서 발생하는 문제점: `관람객과 판매원이 소극장의 통제를 받는 수동적인 존재`
- 관람객의 입장에서 소극장이라는 제 3자가 초대장을 확인하기 위해 관람객의 가방을 마음대로 열어봄
- 판매원 역시 소극장이 매표소에 보관 중인 티켓과 현금에 마음대로 접근함
- 또한, 티켓을 꺼내 관람객의 가방에 집어넣고 관람객의 돈을 적립하는 일을 판매원이 아닌 소극장이 수행함

이해가능한 코드란?
- 우리의 예상에서 크게 벗어나지 않는 코드
- 앞에서 제시한 코드는 우리의 예상을 벗어나는 코드
- 현실에서는 관람객이 직접 자신의 가방에서 초대장을 꺼내 판매원에게 건넨다.
- 판매원은 매표소에 있는 티켓을 직접 꺼내 관람객에게 건네고 관람객에서 돈을 받아 매표소에 보관

코드를 이해하기 어렵게 만드는 또 다른 이유
- 제시한 코드를 이해하기 위해서 많은 내용을 알고 있어야 한다.
- 가령, `Theater`의 `enter` 메서드를 이해하기 위해서는 `Audience`가 `Bag`을 가지고 있고, `Bag`안에는 현금과 티켓이 들어 있으며, `TicketSeller`가 `TicketOffice`에서 티켓을 판매한다는 사실 등을 모두 알아야 한다.

가장 심각한 문제는?
- Audience나 TicketSeller에 변경이 생긴 경우 Theater도 함께 수정해야 한다.


변경에 취약한 코드
- 관람객이 가방을 들고 있지 않다면?
- 관람객이 현금 대신 카드를 들고 있다면?
- 판매원이 매표소 밖에서 티켓을 판매한다면?
- 변경에 취약하다는 것은 == 객체 사이의 의존성(dependency)이 심하다는 뜻
- 객체사이의 의존성을 완전히 없애는 것이 정답인가 ? **X**
	- 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것
	- 객체지향 설계의 목표는 애플리케이션 기능을 구현하며 필요한 최소한의 의존성만 유지하고 불필요한 의존성은 제거하는 것
- 객체 사이의 의존성이 과한 것 == 결합도(coupling)가 높은 것


설계 개선하기
- 앞선 코드의 개선 방법
	- Theater가 Audience와 TicketSeller에 관해 너무 의존성을 갖지 않도록 하기
	- Theater는 관람객이 소극장에 입장하는 것만 신경쓸 수 있도록 코드 수정
	- 관람객이 가방 안의 현금과 초대장을 처리할 수 있도록 코드 수정
	- 판매원이 스스로 매표소의 티켓과 판매 요금을 다룰 수 있도록 코드 수정
	- 즉, 관람객과 판매원을 **자율적인 존재**로 만듦

자율성을 높이기

Theater의 enter 메서드에서 TicketOffice에 접근하는 모든 코드를 TicketSeller 내부로 숨기기
```java
public class TicketSeller {  
  
    private TicketOffice ticketOffice;  
  
    public TicketSeller(TicketOffice ticketOffice) {  
        this.ticketOffice = ticketOffice;  
    }  
  
    public void sellTo(Audience audience) {  
        if (audience.getBag().hasInvitation()) {  
            Ticket ticket = ticketOffice.getTicket();  
            audience.getBag().setTicket(ticket);  
        } else {  
            Ticket ticket = ticketOffice.getTicket();  
            audience.getBag().minusAmount(ticket.getFee());  
            ticketOffice.plusAmount(ticket.getFee());  
            audience.getBag().setTicket(ticket);  
        }  
    }  
}


public class Theater {  
    private TicketSeller ticketSeller;  
  
    public Theater(TicketSeller ticketSeller) {  
        this.ticketSeller = ticketSeller;  
    }  
  
    public void enter(Audience audience) {  
        ticketSeller.sellTo(audience);  
    }  
}
```
- `TicketSeller` 클래스에서 ticketOffice의 가시성은 `private`이고 접근 가능한 퍼블릭 메서드가 사라졌다.(getTicketOffice)
- 결과적으로 ticketOffice에 대한 접근은 오직 `TicketSeller`안에만 존재하게 된다.
- 이처럼 개념적이나 물리적으로 객체 내부의 세부사항을 감추는 것을 캡슐화(capsulation)라 한다.
- 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다.
- 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있다.
- 수정된 Theater 클래스 어디에서도 ticketOffice에 접근하지 않게 수정되었다.
- 즉, Theater는 ticketOffice가 TicketSeller 내부에 존재한다는 사실을 알지 못한다.
- Theater는 오직 ticketSeller의 `인터페이스(Interface)`에만 의존한다.
- TicketSeller가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 `구현(implementation)`의 영역에 속한다.
- 객체를 인터페이스와 구현으로 나누고, 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.


수정 후 클래스 사이의 의존도
![[오브젝트_1.4.png]]


Audience의 캡슐화를 개선
- TicketSeller는 audience의 getBag 메서드를 호출해서 Audience 내부의 Bag 인스턴스에 직접 접근
- Bag 인스턴스에 접근하는 객체가 Theater에서 TicketSeller로 바뀌었을 뿐 Audience는 여전히 자율적인 존재가 아니다.
```java
public class TicketSeller {  
  
    private TicketOffice ticketOffice;  
  
    public TicketSeller(TicketOffice ticketOffice) {  
        this.ticketOffice = ticketOffice;  
    }  
  
    public void sellTo(Audience audience) {  
        ticketOffice.plusAmount(audience.buy(ticketOffice.getTicket()));  
    }  
}

public class Audience {  
    private Bag bag;  
  
    public Audience(Bag bag) {  
        this.bag = bag;  
    }  
  
    public Long buy(Ticket ticket) {  
        if (bag.hasInvitation()) {  
            bag.setTicket(ticket);  
            return 0L;  
        } else {  
            bag.setTicket(ticket);  
            bag.minusAmount(ticket.getFee());  
            return ticket.getFee();  
        }  
    }  
}
```
- TicketSeller와 Audience 사이의 결합도가 낮아짐
- 내부 구현이 캡슐화됐으므로 `Audience`의 구현을 수정하더라도 `TicketSeller`에는 영향을 미치지 않는다.
- 수정된 다이어그램 모습
![[오브젝트_1.6.png]]
- 내부 구현이 캡슐화되어 Audience의 구현을 수정해도 TicketSeller에 영향을 미치지 않는다.


Q. 내부 구현을 외부에 노출하는 코드란?
- 객체지향 프로그래밍에서 캡슐화 원칙을 위반하는 코드
- 캡슐화는 객체의 상태와 동작을 외부에서 감추는 것을 의미
- 예를 들어, `Audience` 클래스의 `getBag()`메서드는 'Bag' 객체를 직접 반환하고 있으며, `TicketSeller` 클래스의 `getTicketOffice()` 메서드도 'TicketOffice' 객체를 직접 반환함
- 이는 외부 코드에서 직접적으로 내부 객체에 접근할 수 있도록 허용함

Q. 여전히 buy라는 메서드의 구현이 바뀌는 경우가 존재할 수 있는데, Audience의 내부 구현을 의존하지 않는다는 의미는?
- 처음 로직과 달리 buy 메서드는 외부에서 'Ticket'을 전달받아 사용한다. 즉, 메서드의 동작이 외부에서 전달된 매개변수에 의존하고 있고, 외부에서 필요한 데이터를 받아오기 때문에 내부 상태에 대한 의존성이 낮아진다. 따라서 내부 구현에 덜 민감하게 설계된 방향이다.
- Audience는 Bag 내부의 내용물을 확인하거나, 추가학



출처:
연결문서
