# 오브젝트 정리_01장
---

날짜: 2024-01-11
태그: #오브젝트
메모:

> 패러다임이란?
> 모델(model), 패턴(pattern), 또는 전형적인 예(example)를 의미하는 그리스어인 '파라데이그마(paradeigma)'에서 유래, 패러다임은 하나의 예를 복사하도록 허용


패러다임 전환(Paradigm Shift)
- 우주를 보는 관점이 천동설에서 지동설로 변화한 사건이 패러다임 전환이 대표 예
- 오브젝트 책에서는  '절차형 패러다임'에서 '객체지향 패러다임'으로 변화를 의미

프로그래밍 패러다임이 필요한 이유
- 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유할 수 있게 함으로써 불필요한 부분에 대한 의견 충돌을 방지
- 프로그래밍 패러다임을 교육시킴으로써 동일한 규칙과 방법을 공유하는 개발자로 성장할 수 있도록 준비

다중패러다임 언어(Multiparadigm Language)
- 하나 이상의 패러다임을 수용하는 언어
- 함수형 패러다임과 객체지향 패러다임을 접목한 스칼라(Scala) 등이 예시


---

티켓 판매 애플리케이션 구현하기

요구사항
- 추첨을 통해 선정된 관람객에게 공연을 무료로 관람할 수 있는 초대장을 발송
- 초대되지 못한 관람객을 티켓을 구매해야만 입장할 수 있음
- 따라서, 관람객을 입장시키기 전에 이벤트 당첨 여부를 확인해야 하고, 이벤트 당첨자가 아닌 경우 티켓을 판매 후 입장시켜야 함

Invitation Class
```Java
public class Invitation {
	private LocalDateTime when;
}
```
- 공연을 관람할 수 있는 초대일자(when)를 인스턴스 변수로 포함하는 간단한 클래스

Ticket Class
```Java
public class Ticket {  
    private Long fee;  
      
    public Long getFee() {  
        return fee;  
    }  
}
```
- 공연을 관람하기 원하는 모든 사람들은 티켓을 소지하고 있어야만 한다.

요구사항 #2
- 이벤트 당첨자는 티켓으로 교환할 초대장을 가지고 있고, 이벤트에 당첨되지 않은 관람객은 티켓을 구매할 현금을 보유하고 있다.
- 따라서 관람객이 가지고 올 수 있는 소지품은 초대장, 현금, 티켓 세 가지뿐이다.
- 관람객은 소지품을 보관할 용도로 가방을 들고 올 수 있다.

Bag Class
```Java
public class Bag {  
    private Long amount;  
    private Invitation invitation;  
    private Ticket ticket;  
      
    public boolean hasInvitation() {  
        return invitation != null;  
    }  
      
    public boolean hasTicket() {  
        return ticket != null;  
    }  
      
    public void setTicket(Ticket ticket) {  
        this.ticket = ticket;  
    }  
      
    public void minusAmount(Long amount) {  
        this.amount -= amount;  
    }  
      
    public void plusAmount(Long amount) {  
        this.amount += amount;  
    }  
}
```
- 관람객이 소지품을 보관할 Bag 클래스
- 초대장(Invitation), 티켓(Ticket), 현금(Amount)을 인스턴스 변수로 포함
- 초대장의 보유 여부를 판단하는 `hasInvitation` 메서드와 티켓의 소유 여부를 판단하는 `hasTicket` 메서드, 현금을 증가시키거나 감소시키는 `plusAmount`와 `minusAmount` 메서드, 초대장을 티켓으로 교환하는 `setTicket` 메서드를 구현


요구사항 #3
- 이벤트에 당첨된 관람객의 가방 안에는 현금과 초대장이 들어있지만 이벤트에 당첨되지 않은 과람객의 가방 안에는 초대장이 들어있지 않을 것이다.
- 따라서 Bag 인스턴스의 상태는 현금과 초대장을 함께 보관하거나, 초대장 없이 현금만 보관하는 두 가지 중 하나일 것이다.
- Bag 인스턴스를 생성하는 시점에 이 제약을 강제할 수 있도록 생성자를 추가

Bag Class
```Java
public class Bag {
	public  Bag(Long amount) {  
	    this(null, amount);  
	}  
	  
	public Bag(Invitation invitation, Long amount) {  
	    this.invitation = invitation;  
	    this.amount = amount;  
	}

	...(생략)
}
```

Audience Class
```Java
public class Audience {  
    private Bag bag;  
  
    public Audience(Bag bag) {  
        this.bag = bag;  
    }  
  
    public Bag getBag() {  
        return bag;  
    }  
}
```
- 관람객이라는 개념을 구현
- 관람객을 소지품을 보관하기 위해 가방을 소지할 수 있음

요구사항 #4
- 관람객이 소극장에 입장하기 위해서는 매표소에서 초대장을 티켓으로 교환하거나 구매해야 함
- 따라서 매표소에는 관람객에게 판매할 티켓과 티켓의 판매 금액이 보관
- 매표소를 구현하기 위해 `TicketOffice` 클래스를 추가
- `TicketOffice`는 판매하거나 교환해 줄 티켓의 목록(tickets)과 판매 금액(amount)을 인스턴스 변수로 포함
- 티켓을 판매하는 `getTicket` 메서드는 편의를 위해 tickets 컬렉션에서 맨 첫 번째 위치에 저장된 Ticket을 반환하는 것으로 구현
- 또한 판매금액을 더하거나 차감하는 `plusAmount`와 `minusAmount` 메서드도 구현

TicketOffice Class
```Java
public class TicketOffice {  
      
    private Long amount;  
    private List<Ticket> tickets = new ArrayList<>();  
      
    public TicketOffice(Long amount, Ticket ... tickets) {  
        this.amount = amount;  
        this.tickets.addAll(Arrays.asList(tickets));  
    }  
      
    public Ticket getTicket() {  
        return tickets.remove(0);  
    }  
      
    public void minusAmount(Long amount) {  
        this.amount -= amount;  
    }  
      
    public void plusAmount(Long amount) {  
        this.amount += amount;  
    }  
}
```


TicketSeller Class
```java
public class TicketSeller {  
      
    private TicketOffice ticketOffice;  
      
    public TicketSeller(TicketOffice ticketOffice) {  
        this.ticketOffice = ticketOffice;  
    }  
      
    public TicketOffice getTicketOffice() {  
        return ticketOffice;  
    }  
}
```
- 판매원 클래스
- 매표소에서 초대장을 티켓으로 교환해 주거나 티켓을 판매하는 역할을 수행
- 판매원을 구현한 `TicketSeller` 클래스는 자신이 일하는 매표소(TicketOffice)를 알아야 함

애플리케이션 핵심 클래스 정리
![[오브젝트_1.1.png]]
- 애플리케이션 핵심 클래스 중간정리

요구사항 #5
- 소극장을 구현하는 클래스는 `Theater`
- Theater 클래스가 관람객을 맞이할 수 있도록 enter 메서드를 구현
```java
public class Theater {  
    private TicketSeller ticketSeller;  
  
    public Theater(TicketSeller ticketSeller) {  
        this.ticketSeller = ticketSeller;  
    }  
  
    public void enter(Audience audience) {  
        if (audience.getBag().hasInvitation()) {  
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();  
            audience.getBag().setTicket(ticket);  
        } else {  
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();  
            audience.getBag().minusAmount(ticket.getFee());  
            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());  
            audience.getBag().setTicket(ticket);  
        }  
    }  
}
```

위 요구사항을 구현한 코드들의 문제점

모듈의 세 가지 목적(클린 소프트웨어: 애잘일 원칙과 패턴, 그리고 실천 방법, 로버트 마틴)
> 모든 소프트웨어 모듈에는 세 가지 목적이 있다.
> 첫 번째: 실행 중에 제대로 동작하는 것
> 두 번째: 변경을 위해 존재하는 것, 대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 함, 변경하기 어려운 모듈은 제대로 동작하더라도 개선해야 함
> 세 번째: 모듈은 코드를 읽는 사람과 의사소통하는 것, 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 함


예상을 빗나가는 코드

Theater 클래스의 enter 메서드가 수행하는 일을 말로 풀었을 때
> 소극장은 관람객의 가방을 열어 그 안에 초대장이 있는지 확인, 가방에 초대장이 있으면 판매원은 매표소에 있는 티켓을 관람객의 가방으로 옮긴다. 가방 안에 초대장이 없으면 관람객의 가방에서 티켓 금액만큼의 현금을 꺼내 매표소에 적립 후 티켓을 관람객의 가방에 옮긴다.
- 위의 예시에서 발생하는 문제점: `관람객과 판매원이 소극장의 통제를 받는 수동적인 존재`
- 관람객의 입장에서 소극장이라는 제 3자가 초대장을 확인하기 위해 관람객의 가방을 마음대로 열어봄
- 판매원 역시 소극장이 매표소에 보관 중인 티켓과 현금에 마음대로 접근함
- 또한, 티켓을 꺼내 관람객의 가방에 집어넣고 관람객의 돈을 적립하는 일을 판매원이 아닌 소극장이 수행함

이해가능한 코드란?
- 우리의 예상에서 크게 벗어나지 않는 코드
- 앞에서 제시한 코드는 우리의 예상을 벗어나는 코드
- 현실에서는 관람객이 직접 자신의 가방에서 초대장을 꺼내 판매원에게 건넨다.
- 판매원은 매표소에 있는 티켓을 직접 꺼내 관람객에게 건네고 관람객에서 돈을 받아 매표소에 보관

코드를 이해하기 어렵게 만드는 또 다른 이유
- 제시한 코드를 이해하기 위해서 많은 내용을 알고 있어야 한다.
- 가령, `Theater`의 `enter` 메서드를 이해하기 위해서는 `Audience`가 `Bag`을 가지고 있고, `Bag`안에는 현금과 티켓이 들어 있으며, `TicketSeller`가 `TicketOffice`에서 티켓을 판매한다는 사실 등을 모두 알아야 한다.

가장 심각한 문제는?
- Audience나 TicketSeller에 변경이 생긴 경우 Theater도 함께 수정해야 한다.


변경에 취약한 코드
- 관람객이 가방을 들고 있지 않다면?
- 관람객이 현금 대신 카드를 들고 있다면?
- 판매원이 매표소 밖에서 티켓을 판매한다면?
- 변경에 취약하다는 것은 == 객체 사이의 의존성(dependency)이 심하다는 뜻
- 객체사이의 의존성을 완전히 없애는 것이 정답인가 ? **X**
	- 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것
	- 객체지향 설계의 목표는 애플리케이션 기능을 구현하며 필요한 최소한의 의존성만 유지하고 불필요한 의존성은 제거하는 것
- 객체 사이의 의존성이 과한 것 == 결합도(coupling)가 높은 것


설계 개선하기
- 앞선 코드의 개선 방법
	- Theater가 Audience와 TicketSeller에 관해 너무 의존성을 갖지 않도록 하기
	- Theater는 관람객이 소극장에 입장하는 것만 신경쓸 수 있도록 코드 수정
	- 관람객이 가방 안의 현금과 초대장을 처리할 수 있도록 코드 수정
	- 판매원이 스스로 매표소의 티켓과 판매 요금을 다룰 수 있도록 코드 수정
	- 즉, 관람객과 판매원을 **자율적인 존재**로 만듦

자율성을 높이기

Theater의 enter 메서드에서 TicketOffice에 접근하는 모든 코드를 TicketSeller 내부로 숨기기
```java
public class TicketSeller {  
  
    private TicketOffice ticketOffice;  
  
    public TicketSeller(TicketOffice ticketOffice) {  
        this.ticketOffice = ticketOffice;  
    }  
  
    public void sellTo(Audience audience) {  
        if (audience.getBag().hasInvitation()) {  
            Ticket ticket = ticketOffice.getTicket();  
            audience.getBag().setTicket(ticket);  
        } else {  
            Ticket ticket = ticketOffice.getTicket();  
            audience.getBag().minusAmount(ticket.getFee());  
            ticketOffice.plusAmount(ticket.getFee());  
            audience.getBag().setTicket(ticket);  
        }  
    }  
}


public class Theater {  
    private TicketSeller ticketSeller;  
  
    public Theater(TicketSeller ticketSeller) {  
        this.ticketSeller = ticketSeller;  
    }  
  
    public void enter(Audience audience) {  
        ticketSeller.sellTo(audience);  
    }  
}
```
- `TicketSeller` 클래스에서 ticketOffice의 가시성은 `private`이고 접근 가능한 퍼블릭 메서드가 사라졌다.(getTicketOffice)
- 결과적으로 ticketOffice에 대한 접근은 오직 `TicketSeller`안에만 존재하게 된다.
- 이처럼 개념적이나 물리적으로 객체 내부의 세부사항을 감추는 것을 캡슐화(capsulation)라 한다.
- 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다.
- 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있다.
- 수정된 Theater 클래스 어디에서도 ticketOffice에 접근하지 않게 수정되었다.
- 즉, Theater는 ticketOffice가 TicketSeller 내부에 존재한다는 사실을 알지 못한다.
- Theater는 오직 ticketSeller의 `인터페이스(Interface)`에만 의존한다.
- TicketSeller가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 `구현(implementation)`의 영역에 속한다.
- 객체를 인터페이스와 구현으로 나누고, 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.


수정 후 클래스 사이의 의존도
![[오브젝트_1.4.png]]


Audience의 캡슐화를 개선
- TicketSeller는 audience의 getBag 메서드를 호출해서 Audience 내부의 Bag 인스턴스에 직접 접근
- Bag 인스턴스에 접근하는 객체가 Theater에서 TicketSeller로 바뀌었을 뿐 Audience는 여전히 자율적인 존재가 아니다.
```java
public class TicketSeller {  
  
    private TicketOffice ticketOffice;  
  
    public TicketSeller(TicketOffice ticketOffice) {  
        this.ticketOffice = ticketOffice;  
    }  
  
    public void sellTo(Audience audience) {  
        ticketOffice.plusAmount(audience.buy(ticketOffice.getTicket()));  
    }  
}

public class Audience {  
    private Bag bag;  
  
    public Audience(Bag bag) {  
        this.bag = bag;  
    }  
  
    public Long buy(Ticket ticket) {  
        if (bag.hasInvitation()) {  
            bag.setTicket(ticket);  
            return 0L;  
        } else {  
            bag.setTicket(ticket);  
            bag.minusAmount(ticket.getFee());  
            return ticket.getFee();  
        }  
    }  
}
```
- TicketSeller와 Audience 사이의 결합도가 낮아짐
- 내부 구현이 캡슐화됐으므로 `Audience`의 구현을 수정하더라도 `TicketSeller`에는 영향을 미치지 않는다.
- 수정된 다이어그램 모습
![[오브젝트_1.6.png]]
- 내부 구현이 캡슐화되어 Audience의 구현을 수정해도 TicketSeller에 영향을 미치지 않는다.


Q. 내부 구현을 외부에 노출하는 코드란?
- 객체지향 프로그래밍에서 캡슐화 원칙을 위반하는 코드
- 캡슐화는 객체의 상태와 동작을 외부에서 감추는 것을 의미
- 예를 들어, `Audience` 클래스의 `getBag()`메서드는 'Bag' 객체를 직접 반환하고 있으며, `TicketSeller` 클래스의 `getTicketOffice()` 메서드도 'TicketOffice' 객체를 직접 반환함
- 이는 외부 코드에서 직접적으로 내부 객체에 접근할 수 있도록 허용함

Q. 여전히 buy라는 메서드의 구현이 바뀌는 경우가 존재할 수 있는데, Audience의 내부 구현을 의존하지 않는다는 의미는?
- 처음 로직과 달리 buy 메서드는 외부에서 'Ticket'을 전달받아 사용한다. 즉, 메서드의 동작이 외부에서 전달된 매개변수에 의존하고 있고, 외부에서 필요한 데이터를 받아오기 때문에 내부 상태에 대한 의존성이 낮아진다. 따라서 내부 구현에 덜 민감하게 설계된 방향이다.
- Audience는 Bag 내부의 내용물을 확인하거나, 추가하거나, 제거하는 작업을 스스로 처리하며, 외부의 누군가에게 자신의 가방을 열어보도록 허용하지 않도록 변경되었다. 즉, 내부 작업이 캡슐화되어 있는 상태이다.


절차지향과 객체지향
- Theater의 enter 메서드는 프로세스(Process)이며, Audience, TicketSeller, Bag, TicketOffice는 데이터(Data)이다.
- 이처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍(Procedural Programming)이라 한다.
- 일반적으로 절차적 프로그래밍은 우리의 직관에 위배된다. 절차적 프로그래밍에서 관람객과 판매원은 수동적인 존재이다.
- 더 큰 문제는 절차적 프로그래밍에서 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어렵다는 것이다.
- 절차적 프로그래밍은 프로세스가 필요한 모든 데이터를 의존해야 한다는 근본적인 문제점 때문에 변경에 취약할 수밖에 없다.
- 해결 방법은 프로세스의 적절한 단계를 Data로 이동시키는 것이다.
- 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식을 객체지향 프로그래밍(Object-Oriented Programming)이라 부른다.


책임의 이동
- 객체지향 설계에서는 독재자가 존재하지 않고, 각 객체에 책임이 적절하게 분배된다.
- 따라서 각 객체는 자신을 스스로 책임진다.

Bag 클래스 개선
- Bag을 Audience에 수동적이지 않은 자율적인 로직으로 개선
```java
public class Bag {  
    private Long amount;  
    private Invitation invitation;  
    private Ticket ticket;  
      
    public Long hold(Ticket ticket) {  
        if (hasInvitation()) {  
            setTicket(ticket);  
            return 0L;  
        } else {  
            setTicket(ticket);  
            minusAmount(ticket.getFee());  
            return ticket.getFee();  
        }  
    }  
  
    public boolean hasInvitation() {  
        return invitation != null;  
    }  
      
    public void setTicket(Ticket ticket) {  
        this.ticket = ticket;  
    }  
  
    public void minusAmount(Long amount) {  
        this.amount -= amount;  
    }  
}
```

TicketOffice 클래스 개선
```java
public class TicketOffice {  
    private Long amount;  
    private List<Ticket> tickets = new ArrayList<>();  
  
    public void sellTicketTo(Audience audience) {  
        plusAmount(audience.buy(getTicket()));  
    }  
  
    private Ticket getTicket() {  
        return tickets.remove(0);  
    }  
  
    private void plusAmount(Long amount) {  
        this.amount += amount;  
    }  
}

public class TicketSeller {  
  
    private TicketOffice ticketOffice;  
  
    public TicketSeller(TicketOffice ticketOffice) {  
        this.ticketOffice = ticketOffice;  
    }  
  
    public void sellTo(Audience audience) {  
        ticketOffice.sellTicketTo(audience);  
    }  
}
```


변경 코드의 문제점
- TicketOffice와 Audience 사이에 의존성이 추가
- 변경 전에는 TicketOffice가 Audience에 대해 알지 못했었는데, 변경 후에는 TicketOffice가 Audience에게 직접 티켓을 판매하기 때문에 의존성이 생김
- Audience에 대한 결합도와 TicketOffice의 자율성에 대한 Trade-off가 발생

의인화
- 현실에서 가방에서 돈을 꺼내는 것은 관람객이지 가방이 아니다.
- 소극장에 관람객이 입장하기 위해서도 누군가 소극장의 문을 열고 입장 허가를 해줘야 한다.
- 비록, 현실에서는 수동적인 존재라 하더라도 객체지향 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다.
- 레베카 워프스브룩은 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 가리켜 의인화(anthropomorphism)이라 부른다.


좋은 설계란 무엇인가?
- 우리가 짜는 프로그램은 두 가지 요구사항을 만족시켜야 한다.
- 기능을 구현하는 코드를 짜기 + 내일 쉽게 변경할 수 있는 코드를 짜기


Q. TicketOffice 개선하는 방법
- SOLID 5원칙 중 DIP(Dependency Inversion Principle)
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 의미
- 다음과 같은 Audience에 대한 인터페이스를 만들어 관리
```java
public interface Customer {
    Long buy(Ticket ticket);
}

public class Audience implements Customer {
    // Audience 클래스의 내용은 그대로 유지
}

public class TicketOffice {
    private Long amount;
    private List<Ticket> tickets = new ArrayList<>();

    public Long sellTicketTo(Customer customer) {
        return plusAmount(customer.buy(getTicket()));
    }

    private Ticket getTicket() {
        return tickets.remove(0);
    }

    private Long plusAmount(Long amount) {
        this.amount += amount;
        return this.amount;
    }
}

public class TicketSeller {

    private TicketOffice ticketOffice;

    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public void sellTo(Customer customer) {
        ticketOffice.sellTicketTo(customer);
    }
}

```


영화 예매 시스템 구현

요구사항 #1
- 사용자는 영화 예매 시스템으로 영화를 예매
- '영화'는 영화에 대한 기본 정보를 표현한다. 제목, 상영시간, 가격 정보와 같이 영화가 가진 기본적인 정보를 가리킨다.
- '상영'은 실제로 관객들이 영화를 관람하는 사건을 표현
- 사용자가 실제로 예매하는 대상은 영화가 아니라 상영
- 특정한 조건을 만족하는 예매자는 요금을 할인받을 수 있음
- 할인액을 결정하는 두 가지 규칙이 존재
	- 할인조건(discount condition)
	- 할인 정책(discount policy)
- 할인 조건은 가격의 할인 여부를 결정하며, '순서 조건'과 '기간 조건'의 두 종류로 나뉨
- 순서 조건은 상영 순번을 이용해 할인 여부를 결정하는 규칙
- 기간 조건은 영화 상영 시간을 이용해 할인 여부를 결정
- 할인 정책은 할인 요금을 결정
- 할인 정책에는 '금액 할인 정책'과 '비율 할인 정책'이 있다.
- 금액 할인 정책은 예매 요금에서 일정 금액을 할인해주는 방식
- 비율 할인 정책은 정가에서 일정 비율의 요금을 할인해주는 방식
- 영화별로 하나의 할인 정책만 할당할 수 있고, 할인 정책을 지정하지 않는 것도 가능하다.
- 할인 조건은 다수의 할인 조건을 함께 지정할 수 있으며, 순서 조건과 기간 조건을 섞는 것도 가능하다.
- 할인을 적용하기 위해서는 할인 조건과 할인 정책을 함께 조합해서 사용
- 할인 조건을 만족하는지 먼저 확인하고 할인 조건을 만족할 경우 할인 정책을 이용해 할인 요금을 계산


어떤 클래스가 필요한가?
- 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민
- 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것
- 객체는 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 생각
- 객체는 홀로 존재하는 것이 아니다.

도메인(domain)
- 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라 한다.
![[영화예매도메인.png]]
- 영화 예매 도메인의 예시
- 일반적으로 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 유사하게 지어야 한다.


상영 클래스 구현
```java
public class Screening {  
    private Movie movie;  
    private int sequence;  
    private LocalDateTime whenScreened;  
      
    public Screening(Movie movie, int sequence, LocalDateTime whenScreened) {  
        this.movie = movie;  
        this.sequence = sequence;  
        this.whenScreened = whenScreened;  
    }  
      
    public LocalDateTime getStartTime() {  
        return whenScreened;  
    }  
      
    public boolean isSequence(int sequence) {  
        return this.sequence == sequence;  
    }  
      
    public Money getMovieFee() {  
        return movie.getFee();  
    }  
}
```
- 인스턴스 변수의 가시성은 private
- 메서드의 가시성은 public
- 외부에서는 객체의 속성에 직접 접근할 수 없도록 막고 적절한 public 메서드를 통해서만 내부 상태를 변경해야 한다.

자율적인 객체
- 객체는 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재이다.
- 객체는 스스로 판단하고 행동하는 자율적인 존재이다.
- 객체 안에 데이터와 기능을 함께 묶는 것을 캡슐화라고 부른다.
- 캡슐화에서 나아가, 외부에서 접근을 통제할 수 있는 접근제어(access control) 메커니즘도 함께 제공한다.
- 객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다.
- 객체가 자율적인 존재로 존재하기 위해서는 외부의 간섭을 최소화해야 한다.
- 외부에서는 객체가 어떤 상태에 놓여 있는지, 어떤 생각을 하고 있는지 알아선 안 된다.


캡슐화와 접근 제어
- 퍼블릭 인터페이스(public interface): 외부에서 접근 가능한 부분 
- 구현(implementation): 외부에서는 접근이 불가능하고 오직 내부에서만 접근 가능한 부분


협력
- 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청(request)
- 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답(response)
- 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것
- 다른 객체에게 요청이 도착할 때 해당 객체가 메시지를 수신했다고 표현
- 메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정
- 이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드라 부른다.


무비 클래스
```java
public class Movie {  
    private String title;  
    private Duration runningTime;  
    private Money fee;  
    private DiscountPolicy discountPolicy;  
  
    public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {  
        this.title = title;  
        this.runningTime = runningTime;  
        this.fee = fee;  
        this.discountPolicy = discountPolicy;  
    }  
  
    public Money getFee() {  
        return fee;  
    }  
  
    public Money calculateMovieFee(Screening screening) {  
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));  
    }  
}
```
- 해당 코드에는 어떤 할인 정책을 사용할 것인지 결정하는 코드가 없다.
- 단지, discountPolicy에게 메시지를 전송할 뿐이다.
- 위 코드에는 상속과 다형성 개념, 그리고 추상화 개념이 혼재되어 있다.

DiscountPolicy 클래스
```java
public class DiscountPolicy {  
    private List<DiscountCondition> conditions = new ArrayList<>();  
  
    public DiscountPolicy(DiscountCondition ... conditions) {  
        this.conditions = Arrays.asList(conditions);  
    }  
  
    public Money calculateDiscountAmount(Screening screening) {  
        for(DiscountCondition each : conditions) {  
            if (each.isSatisfiedBy(screening)) {  
                return getDiscountAmount(screening);  
            }  
        }  
  
        return Money.ZERO;  
    }  
  
    abstract protected Money getDiscountAmount(Screening screening);  
}
```
- DiscountPolicy는 DiscountCondition의 리스트인 conditions를 인스턴스 변수로 가진다.
- 때문에 하나의 할인 정책은 여러 개의 할인 조건을 포함할 수 있다.
- `calculatedDiscountAmount`메서드는 전체 할인 조건에 대해 차례로 `isSatisfiedBy` 메서드를 호출한다.
- 할인 조건을 만족하는 DiscountCondition이 하나라도 존재하는 경우 추상 메서드인 getDiscountAmount 메서드를 호출해 할인 요금을 계산한다.
- 만족하는 할인 조건이 하나도 존재하지 않는다면 할인 요금으로 0원을 반환한다.
- DiscountPolicy는 할인 여부와 요금 계산에 필요한 전체적인 흐름은 정의하지만 실제로 요금을 계산하는 부분은 추상 메서드인 getDiscountAmount 메서드에 위임한다.
- 실제로는 DiscountPolicy를 상속받은 자식 클래스에서 오버라이딩한 메서드가 실행될 것이다.
- 이처럼 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에 위임하는 디자인 패턴을 `Template Method 패턴` 이라 부른다.


할인 조건 클래스
```java
public interface DiscountCondition {  
    boolean isSatisfiedBy(Screening screening);  
}

public class SequenceCondition implements DiscountCondition {  
    private int sequence;  
  
    public SequenceCondition(int sequence) {  
        this.sequence = sequence;  
    }  
  
    public boolean isSatisfiedBy(Screening screening) {  
        return screening.isSequence(sequence);  
    }
}

public class PeriodCondition implements DiscountCondition{  
    private DayOfWeek dayOfWeek;  
    private LocalTime startTime;  
    private LocalTime endTime;  
  
    public PeriodCondition(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime){  
        this.dayOfWeek = dayOfWeek;  
        this.startTime = startTime;  
        this.endTime = endTime;  
    }  
      
    public boolean isSatisfiedBy(Screening screening){  
        return screening.getStartTime().getDayOfWeek().equals(dayOfWeek) &&  
            startTime.compareTo(screening.getStartTime().toLocalTime()) <= 0 &&  
            endTime.compareTo(screening.getStartTime().toLocalTime()) >= 0;  
    }  
}
```
- PeriodCondition은 상영 시간이 특정 기간 안에 포함되는지 여부를 판단해 할인 여부를 결정
- 조건에 사용할 요일(dayOfWeek), 시작 시간(startTime), 종료 시간(endTime)을 인스턴스 변수로 포함한다.
- `isSatisfied` 메서드는 인자로 전달된 Screening의 상영 요일이 dayOfWeek와 같고 상영 시작 시간이 startTime과 endTime 사이에 있을 경우 true를, 그렇지 않을 경우 false를 반환한다.


할인 정책 클래스
```java
public class AmountDiscountPolicy extends DiscountPolicy {  
    private Money discountAmount;  
  
    public AmountDiscountPolicy(Money discountAmount, DiscountCondition ... conditions) {  
        super(conditions);  
        this.discountAmount = discountAmount;  
    }
    
    @Override  
	protected Money getDiscountAmount(Screening screening) {  
	    return discountAmount;  
	}
}

public class PercentDiscountPolicy extends  DiscountPolicy {  
    private double percent;  
  
    public PercentDiscountPolicy(double percent, DiscountCondition ... conditions) {  
        super(conditions);  
        this.percent = percent;  
    }  
  
    @Override  
    protected Money getDiscountAmount(Screening screening) {  
        return screening.getMovieFee().times(percent);  
    }  
}


```


의존성
- 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다.
- 다시 말해 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.
- 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다.
- 즉, 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다.
- 반면 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아진다.


상속
- 객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법
- 상속을 이용하면 클래스 사이에 관계를 설정하는 것만으로 기존 클래스가 갖는 모든 속성과 행동을 새로운 클래스에 포함시킬 수 있다.
- 상속은 기존 클래스를 기반으로 새로운 클래스를 쉽고 빠르게 추가할 수 있다.
- 또한 부모 클래스의 구현은 공유하면서도 행동이 다른 자식 클래스를 쉽게 추가할 수 있다.
- 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 `차이에 의한 프로그래밍(programming by difference)`이라 한다.


상속과 인터페이스
- 상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려 받을 수 있기 때문이다.
- 이것은 상속을 바라보는 일반적인 인식, 즉 상속의 목적이 메서드나 인스턴스 변수를 재사용하는 것이라는 것과 거리가 있다.
- 인터페이스는 객체가 이해할 수 있는 메시지의 목록이다.
- 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 된다.
- 결과적으로 자식 클래스는 부모 클래스가 수신하는 모든 메시지를 수신할 수 있기 때문에 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다.
- 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅(upcasting)이라 부른다.
- 자식 클래스가 부모 클래스로 자동 타입 캐스팅이 되는 것처럼 동작하기 때문에 업캐스팅이라 부른다.


다형성
- 메시지와 메서드는 다른 개념이다.
	- Movie는 DiscountPolicy의 인스턴스에 메시지를 보낸다.
	- 그렇다면 실행되는 메서드는 무엇인가?
	- Movie와 상호작용하기 위해 연결된 객체의 클래스가 무엇인지에 따라 다르다.
- 즉, 객체는 동일한 메시지를 전송하지만, 실제로 어떤 메서드가 실행되는지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다.
- 이를 다형성이라 부른다.
- 다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다.
- 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다. 다시 말해 인터페이스가 동일해야 한다.
- 메시지와 메서드를 실행 시점에 바인딩하는 것을 지연 바인딩(lazy binding) 또는 동적 바인딩(dynamic binding)이라 한다.
- 그에 반해 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 초기 바인딩(early binding) 또는 정적 바인딩(static binding)이라 한다.


> 구현 상속과 인터페이스 상속
> 상속은 구현 상속과 인터페이스 상속으로 분류할 수 있다. 흔히 구현 상속을 서브클래싱(subclassing)이라 부르고 인터페이스 상속을 서브타이핑(subtyping)이라 부른다. 순수하게 코드를 재사용하기 위한 목적으로 상속을 구현하는 것을 구현 상속이라 하고, 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것을 인터페이스 상속이라 부른다.


인터페이스와 다형성
- 클래스를 상속할 때 구현은 공유할 필요가 없고 순수하게 인터페이스만 공유하고 싶을 때가 있다.
- 이럴 때 자바에서는 '인터페이스'라는 프로그래밍 요소를 제공한다.
- 자바의 인터페이스는 말 그대로 구현에 대한 고려 없이 다형적인 협력에 참여하는 클래스들이 공유 가능한 외부 인터페이스를 정의한 것이다.


추상화
- 추상화를 사용하면 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다.
- 추상화의 이런 특징은 세부사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요 개념을 설명할 수 있게 한다.
- 추상화를 이용해 상위 정책을 기술한다는 것은 기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미한다.
- 추상화를 이용해 상위 정책을 표현하면 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다.


코드 재사용
- 합성(composition)은 코드 재사용을 위해서 사용되는 방법
- 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말한다.
- 코드 재사용에는 상속 보다는 합성이 선호된다.

상속이 합성보다 안좋은 이유
- 상속은 두 가지 관점에서 설계에 안 좋은 영향을 미친다.
	- 하나는 상속이 캡슐화를 위반한다는 것
	- 다른 하나는 설계를 유연하지 못하게 만든다는 것
- 상속의 가장 큰 문제는 캡슐화를 위반한다는 것
	- 상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다.
	- 자식 클래스에서는 부모 클래스의 구현이 노출되기 때문에 캡슐화가 약화된다.
	- 캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률이 높다.
	- 결과적으로 상속을 과도하게 사용한 코드는 변경하기 어렵다.
- 상속의 두 번째 단점은 설계가 유연하지 않다는 것이다.
	- 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다.
	- 따라서 실행 시점의 객체의 종류를 변경하는 것이 불가능하다.

합성
- 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성이라고 부른다.
- 합성은 상속이 갖는 두 가지 문제점을 모두 해결한다.
	- 인터페이스에 정의된 메시지를 통해서만 재사용 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다.
	- 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다.


협력을 다시 정리
- 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 협력이라고 한다.
- 객체가 협력에 참여하기 위해 수행하는 로직은 책임이라고 한다.
- 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구현한다.
- 협력은 객체지향의 세계에서 기능을 구현하는 유일한 방법
- 두 객체 사이의 협력은 하나의 객체가 다른 객체에게 도움을 요청할 때 시작된다.
- `메시지 전송`은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단이다.
- 메시지를 수신한 객체는 메서드를 실행해 요청에 응답한다.
- 여기서 객체는 메시지를 처리할 방법을 스스로 선택한다.
- 즉, 외부의 객체는 오직 메시지만 전송할 수 있을 뿐이며 메시지를 어떻게 처리할지는 메시지를 수신한 객체가 직접 결정한다.


협력이 설계를 위한 문맥을 결정
- 객체란 상태와 행동을 함께 캡슐화하는 실행 단위
- 그렇다면 객체가 가질 수 있는 상태와 행동을 어떤 기준으로 결정해야 할까?
- 객체를 설계할 때 어떤 행동과 상태를 할당했다면 그 이유는 무엇인가?
- 애플리케이션 안에 어떤 객체가 필요하다면 그 이유는 단 하나여야 한다.
	- 그 객체가 어떤 협력에 참여하고 있다는 것
	- 그리고 객체가 협력에 참여할 수 있는 이유는 협력에 필요한 적절한 행동을 보유하고 있기 때문
- 결론적으로 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력
- 협력이 바뀌면 객체가 제공해야 하는 행동 역시 바뀌어야 한다.
- 협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다.
- 객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동이다.
- 객체의 상태는 그 객체가 행동을 수행하는 데 필요한 정보가 무엇인지로 결정된다.


책임이란 무엇인가
- 객체가 협력에 참여하기 위해 수행하는 행동을 `책임`이라 부른다.
- 책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합
- 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장
- 즉, 객체의 책임은 객체가 '무엇을 알고 있는가'와 '무엇을 할 수 있는가'로 구성된다.

```
하는 것
- 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것
- 다른 객체의 행동을 시작시키는 것
- 다른 객체의 활동을 제어하고 조절하는 것

아는 것
- 사적인 정보에 관해 아는 것
- 관련된 객체에 관해 아는 것
- 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것
```

책임
- 협력 안에서 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정한다.
- 일반적으로 책임과 메시지의 크기는 다르다.
	- 책임은 객체가 수행할 수 있는 행동을 종합적이고 간략하게 서술
	- 때문에 메시지보다 추상적이로 개념적으로 크다
	- 처음에는 단순한 책임도 여러 개의 메시지로 분할되거나 하나의 객체가 수행할 수 있다고 생각했던 책임이 나중에 여러 객체들이 협력해야 하는 커다란 책임이 될 수 있다.
- 책임의 관점에서 '아는 것'과 '하는 것'은 밀접하게 연관돼 있다.
	- 객체는 자신이 맡은 책임을 수행하는 데 필요한 정보를 알고 있을 책임이 있다.
	- 객체는 자신이 할 수 없는 작업을 도와줄 객체를 알고 있을 책임이 있다.
	- 어떤 책임을 수행하기 위해서는 그 책임을 수행하는 데 필요한 정보도 함께 알아야 할 책임이 있다.
- 책임은 객체지향 설계의 핵심이다.
- 적절한 협력이 적절한 책임을 제공하고, 적절한 책임을 적절한 객체에게 할당해야만 단순하고 유연한 설계를 창조할 수 있다.


책임 할당
- 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것
- 이를 책임 할당을 위한 `Information Expert(정보 전문가)`패턴이라 부른다.
- 객체지향 설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이루어진다.
- 그리고 이런 메시지가 메시지를 수신할 객체의 책임을 결정한다.
- 이렇게 결정된 메시지가 객체의 퍼블릭 인터페이스를 구성한다는 것도 중요하다
- 협력을 설계하면서 객체의 책임을 식별해 나가는 과정을 통해 시스템을 구성하는 객체들의 인터페이스와 오퍼레이션 목록을 얻을 수 있다.


책임 주도 설계
- 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 '책임 주도 설계(Responsibility-Driven Design, RDD)'이라 부른다.
- 책임 주도 설계 방법의 과정
- 


출처: 오브젝트

연결문서
