# 오브젝트 정리_01장
---

날짜: 2024-01-11
태그: #오브젝트
메모:

> 패러다임이란?
> 모델(model), 패턴(pattern), 또는 전형적인 예(example)를 의미하는 그리스어인 '파라데이그마(paradeigma)'에서 유래, 패러다임은 하나의 예를 복사하도록 허용


패러다임 전환(Paradigm Shift)
- 우주를 보는 관점이 천동설에서 지동설로 변화한 사건이 패러다임 전환이 대표 예
- 오브젝트 책에서는  '절차형 패러다임'에서 '객체지향 패러다임'으로 변화를 의미

프로그래밍 패러다임이 필요한 이유
- 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유할 수 있게 함으로써 불필요한 부분에 대한 의견 충돌을 방지
- 프로그래밍 패러다임을 교육시킴으로써 동일한 규칙과 방법을 공유하는 개발자로 성장할 수 있도록 준비

다중패러다임 언어(Multiparadigm Language)
- 하나 이상의 패러다임을 수용하는 언어
- 함수형 패러다임과 객체지향 패러다임을 접목한 스칼라(Scala) 등이 예시


---

티켓 판매 애플리케이션 구현하기

요구사항
- 추첨을 통해 선정된 관람객에게 공연을 무료로 관람할 수 있는 초대장을 발송
- 초대되지 못한 관람객을 티켓을 구매해야만 입장할 수 있음
- 따라서, 관람객을 입장시키기 전에 이벤트 당첨 여부를 확인해야 하고, 이벤트 당첨자가 아닌 경우 티켓을 판매 후 입장시켜야 함

Invitation Class
```Java
public class Invitation {
	private LocalDateTime when;
}
```
- 공연을 관람할 수 있는 초대일자(when)를 인스턴스 변수로 포함하는 간단한 클래스

Ticket Class
```Java
public class Ticket {  
    private Long fee;  
      
    public Long getFee() {  
        return fee;  
    }  
}
```
- 공연을 관람하기 원하는 모든 사람들은 티켓을 소지하고 있어야만 한다.

요구사항 #2
- 이벤트 당첨자는 티켓으로 교환할 초대장을 가지고 있고, 이벤트에 당첨되지 않은 관람객은 티켓을 구매할 현금을 보유하고 있다.
- 따라서 관람객이 가지고 올 수 있는 소지품은 초대장, 현금, 티켓 세 가지뿐이다.
- 관람객은 소지품을 보관할 용도로 가방을 들고 올 수 있다.

Bag Class
```Java
public class Bag {  
    private Long amount;  
    private Invitation invitation;  
    private Ticket ticket;  
      
    public boolean hasInvitation() {  
        return invitation != null;  
    }  
      
    public boolean hasTicket() {  
        return ticket != null;  
    }  
      
    public void setTicket(Ticket ticket) {  
        this.ticket = ticket;  
    }  
      
    public void minusAmount(Long amount) {  
        this.amount -= amount;  
    }  
      
    public void plusAmount(Long amount) {  
        this.amount += amount;  
    }  
}
```
- 관람객이 소지품을 보관할 Bag 클래스
- 초대장(Invitation), 티켓(Ticket), 현금(Amount)을 인스턴스 변수로 포함
- 초대장의 보유 여부를 판단하는 `hasInvitation` 메서드와 티켓의 소유 여부를 판단하는 `hasTicket` 메서드, 현금을 증가시키거나 감소시키는 `plusAmount`와 `minusAmount` 메서드, 초대장을 티켓으로 교환하는 `setTicket` 메서드를 구현


요구사항 #3
- 이벤트에 당첨된 관람객의 가방 안에는 현금과 초대장이 들어있지만 이벤트에 당첨되지 않은 과람객의 가방 안에는 초대장이 들어있지 않을 것이다.
- 따라서 Bag 인스턴스의 상태는 현금과 초대장을 함께 보관하거나, 초대장 없이 현금만 보관하는 두 가지 중 하나일 것이다.
- Bag 인스턴스를 생성하는 시점에 이 제약을 강제할 수 있도록 생성자를 추가

Bag Class
```Java
public class Bag {
	public  Bag(Long amount) {  
	    this(null, amount);  
	}  
	  
	public Bag(Invitation invitation, Long amount) {  
	    this.invitation = invitation;  
	    this.amount = amount;  
	}

	...(생략)
}
```

Audience Class
```Java
public class Audience {  
    private Bag bag;  
  
    public Audience(Bag bag) {  
        this.bag = bag;  
    }  
  
    public Bag getBag() {  
        return bag;  
    }  
}
```
- 관람객이라는 개념을 구현
- 관람객을 소지품을 보관하기 위해 가방을 소지할 수 있음

요구사항 #4
- 관람객이 소극장에 입장하기 위해서는 매표소에서 초대장을 티켓으로 교환하거나 구매해야 함
- 따라서 매표소에는 관람객에게 판매할 티켓과 티켓의 판매 금액이 보관
- 매표소를 구현하기 위해 `TicketOffice` 클래스를 추가
- `TicketOffice`는 판매하거나 교환해 줄 티켓의 목록(tickets)과 판매 금액(amount)을 인스턴스 변수로 포함
- 티켓을 판매하는 `getTicket` 메서드는 편의를 위해 tickets 컬렉션에서 맨 첫 번째 위치에 저장된 Ticket을 반환하는 것으로 구현
- 또한 판매금액을 더하거나 차감하는 `plusAmount`와 `minusAmount` 메서드도 구현

TicketOffice Class
```Java
public class TicketOffice {  
      
    private Long amount;  
    private List<Ticket> tickets = new ArrayList<>();  
      
    public TicketOffice(Long amount, Ticket ... tickets) {  
        this.amount = amount;  
        this.tickets.addAll(Arrays.asList(tickets));  
    }  
      
    public Ticket getTicket() {  
        return tickets.remove(0);  
    }  
      
    public void minusAmount(Long amount) {  
        this.amount -= amount;  
    }  
      
    public void plusAmount(Long amount) {  
        this.amount += amount;  
    }  
}
```


TicketSeller Class
```java
public class TicketSeller {  
      
    private TicketOffice ticketOffice;  
      
    public TicketSeller(TicketOffice ticketOffice) {  
        this.ticketOffice = ticketOffice;  
    }  
      
    public TicketOffice getTicketOffice() {  
        return ticketOffice;  
    }  
}
```
- 판매원 클래스
- 매표소에서 초대장을 티켓으로 교환해 주거나 티켓을 판매하는 역할을 수행
- 판매원을 구현한 `TicketSeller` 클래스는 자신이 일하는 매표소(TicketOffice)를 알아야 함

애플리케이션 핵심 클래스 정리
![[오브젝트_1.1.png]]
- 애플리케이션 핵심 클래스 중간정리

요구사항 #5
- 소극장을 구현하는 클래스는 `Theater`
- Theater 클래스가 관람객을 맞이할 수 있도록 enter 메서드를 구현
```java
public class Theater {  
    private TicketSeller ticketSeller;  
  
    public Theater(TicketSeller ticketSeller) {  
        this.ticketSeller = ticketSeller;  
    }  
  
    public void enter(Audience audience) {  
        if (audience.getBag().hasInvitation()) {  
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();  
            audience.getBag().setTicket(ticket);  
        } else {  
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();  
            audience.getBag().minusAmount(ticket.getFee());  
            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());  
            audience.getBag().setTicket(ticket);  
        }  
    }  
}
```

위 요구사항을 구현한 코드들의 문제점

모듈의 세 가지 목적(클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천 방법, 로버트 마틴)
> 모든 소프트웨어 모듈에는 세 가지 목적이 있다.
> 첫 번째: 실행 중에 제대로 동작하는 것
> 두 번째: 변경을 위해 존재하는 것, 대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 함, 변경하기 어려운 모듈은 제대로 동작하더라도 개선해야 함
> 세 번째: 모듈은 코드를 읽는 사람과 의사소통하는 것, 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 함


예상을 빗나가는 코드

Theater 클래스의 enter 메서드가 수행하는 일을 말로 풀었을 때
> 소극장은 관람객의 가방을 열어 그 안에 초대장이 있는지 확인, 가방에 초대장이 있으면 판매원은 매표소에 있는 티켓을 관람객의 가방으로 옮긴다. 가방 안에 초대장이 없으면 관람객의 가방에서 티켓 금액만큼의 현금을 꺼내 매표소에 적립 후 티켓을 관람객의 가방에 옮긴다.
- 위의 예시에서 발생하는 문제점: `관람객과 판매원이 소극장의 통제를 받는 수동적인 존재`
- 관람객의 입장에서 소극장이라는 제 3자가 초대장을 확인하기 위해 관람객의 가방을 마음대로 열어봄
- 판매원 역시 소극장이 매표소에 보관 중인 티켓과 현금에 마음대로 접근함
- 또한, 티켓을 꺼내 관람객의 가방에 집어넣고 관람객의 돈을 적립하는 일을 판매원이 아닌 소극장이 수행함

이해가능한 코드란?
- 우리의 예상에서 크게 벗어나지 않는 코드
- 앞에서 제시한 코드는 우리의 예상을 벗어나는 코드
- 현실에서는 관람객이 직접 자신의 가방에서 초대장을 꺼내 판매원에게 건넨다.
- 판매원은 매표소에 있는 티켓을 직접 꺼내 관람객에게 건네고 관람객에서 돈을 받아 매표소에 보관

코드를 이해하기 어렵게 만드는 또 다른 이유
- 제시한 코드를 이해하기 위해서 많은 내용을 알고 있어야 한다.
- 가령, `Theater`의 `enter` 메서드를 이해하기 위해서는 `Audience`가 `Bag`을 가지고 있고, `Bag`안에는 현금과 티켓이 들어 있으며, `TicketSeller`가 `TicketOffice`에서 티켓을 판매한다는 사실 등을 모두 알아야 한다.

가장 심각한 문제는?
- Audience나 TicketSeller에 변경이 생긴 경우 Theater도 함께 수정해야 한다.


변경에 취약한 코드
- 관람객이 가방을 들고 있지 않다면?
- 관람객이 현금 대신 카드를 들고 있다면?
- 판매원이 매표소 밖에서 티켓을 판매한다면?
- 변경에 취약하다는 것은 == 객체 사이의 의존성(dependency)이 심하다는 뜻
- 객체사이의 의존성을 완전히 없애는 것이 정답인가 ? **X**
	- 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것
	- 객체지향 설계의 목표는 애플리케이션 기능을 구현하며 필요한 최소한의 의존성만 유지하고 불필요한 의존성은 제거하는 것
- 객체 사이의 의존성이 과한 것 == 결합도(coupling)가 높은 것


설계 개선하기
- 앞선 코드의 개선 방법
	- Theater가 Audience와 TicketSeller에 관해 너무 의존성을 갖지 않도록 하기
	- Theater는 관람객이 소극장에 입장하는 것만 신경쓸 수 있도록 코드 수정
	- 관람객이 가방 안의 현금과 초대장을 처리할 수 있도록 코드 수정
	- 판매원이 스스로 매표소의 티켓과 판매 요금을 다룰 수 있도록 코드 수정
	- 즉, 관람객과 판매원을 **자율적인 존재**로 만듦

자율성을 높이기

Theater의 enter 메서드에서 TicketOffice에 접근하는 모든 코드를 TicketSeller 내부로 숨기기
```java
public class TicketSeller {  
  
    private TicketOffice ticketOffice;  
  
    public TicketSeller(TicketOffice ticketOffice) {  
        this.ticketOffice = ticketOffice;  
    }  
  
    public void sellTo(Audience audience) {  
        if (audience.getBag().hasInvitation()) {  
            Ticket ticket = ticketOffice.getTicket();  
            audience.getBag().setTicket(ticket);  
        } else {  
            Ticket ticket = ticketOffice.getTicket();  
            audience.getBag().minusAmount(ticket.getFee());  
            ticketOffice.plusAmount(ticket.getFee());  
            audience.getBag().setTicket(ticket);  
        }  
    }  
}


public class Theater {  
    private TicketSeller ticketSeller;  
  
    public Theater(TicketSeller ticketSeller) {  
        this.ticketSeller = ticketSeller;  
    }  
  
    public void enter(Audience audience) {  
        ticketSeller.sellTo(audience);  
    }  
}
```
- `TicketSeller` 클래스에서 ticketOffice의 가시성은 `private`이고 접근 가능한 퍼블릭 메서드가 사라졌다.(getTicketOffice)
- 결과적으로 ticketOffice에 대한 접근은 오직 `TicketSeller`안에만 존재하게 된다.
- 이처럼 개념적이나 물리적으로 객체 내부의 세부사항을 감추는 것을 캡슐화(capsulation)라 한다.
- 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다.
- 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있다.
- 수정된 Theater 클래스 어디에서도 ticketOffice에 접근하지 않게 수정되었다.
- 즉, Theater는 ticketOffice가 TicketSeller 내부에 존재한다는 사실을 알지 못한다.
- Theater는 오직 ticketSeller의 `인터페이스(Interface)`에만 의존한다.
- TicketSeller가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 `구현(implementation)`의 영역에 속한다.
- 객체를 인터페이스와 구현으로 나누고, 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.


수정 후 클래스 사이의 의존도
![[오브젝트_1.4.png]]


Audience의 캡슐화를 개선
- TicketSeller는 audience의 getBag 메서드를 호출해서 Audience 내부의 Bag 인스턴스에 직접 접근
- Bag 인스턴스에 접근하는 객체가 Theater에서 TicketSeller로 바뀌었을 뿐 Audience는 여전히 자율적인 존재가 아니다.
```java
public class TicketSeller {  
  
    private TicketOffice ticketOffice;  
  
    public TicketSeller(TicketOffice ticketOffice) {  
        this.ticketOffice = ticketOffice;  
    }  
  
    public void sellTo(Audience audience) {  
        ticketOffice.plusAmount(audience.buy(ticketOffice.getTicket()));  
    }  
}

public class Audience {  
    private Bag bag;  
  
    public Audience(Bag bag) {  
        this.bag = bag;  
    }  
  
    public Long buy(Ticket ticket) {  
        if (bag.hasInvitation()) {  
            bag.setTicket(ticket);  
            return 0L;  
        } else {  
            bag.setTicket(ticket);  
            bag.minusAmount(ticket.getFee());  
            return ticket.getFee();  
        }  
    }  
}
```
- TicketSeller와 Audience 사이의 결합도가 낮아짐
- 내부 구현이 캡슐화됐으므로 `Audience`의 구현을 수정하더라도 `TicketSeller`에는 영향을 미치지 않는다.
- 수정된 다이어그램 모습
![[오브젝트_1.6.png]]
- 내부 구현이 캡슐화되어 Audience의 구현을 수정해도 TicketSeller에 영향을 미치지 않는다.


Q. 내부 구현을 외부에 노출하는 코드란?
- 객체지향 프로그래밍에서 캡슐화 원칙을 위반하는 코드
- 캡슐화는 객체의 상태와 동작을 외부에서 감추는 것을 의미
- 예를 들어, `Audience` 클래스의 `getBag()`메서드는 'Bag' 객체를 직접 반환하고 있으며, `TicketSeller` 클래스의 `getTicketOffice()` 메서드도 'TicketOffice' 객체를 직접 반환함
- 이는 외부 코드에서 직접적으로 내부 객체에 접근할 수 있도록 허용함

Q. 여전히 buy라는 메서드의 구현이 바뀌는 경우가 존재할 수 있는데, Audience의 내부 구현을 의존하지 않는다는 의미는?
- 처음 로직과 달리 buy 메서드는 외부에서 'Ticket'을 전달받아 사용한다. 즉, 메서드의 동작이 외부에서 전달된 매개변수에 의존하고 있고, 외부에서 필요한 데이터를 받아오기 때문에 내부 상태에 대한 의존성이 낮아진다. 따라서 내부 구현에 덜 민감하게 설계된 방향이다.
- Audience는 Bag 내부의 내용물을 확인하거나, 추가하거나, 제거하는 작업을 스스로 처리하며, 외부의 누군가에게 자신의 가방을 열어보도록 허용하지 않도록 변경되었다. 즉, 내부 작업이 캡슐화되어 있는 상태이다.


절차지향과 객체지향
- Theater의 enter 메서드는 프로세스(Process)이며, Audience, TicketSeller, Bag, TicketOffice는 데이터(Data)이다.
- 이처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍(Procedural Programming)이라 한다.
- 일반적으로 절차적 프로그래밍은 우리의 직관에 위배된다. 절차적 프로그래밍에서 관람객과 판매원은 수동적인 존재이다.
- 더 큰 문제는 절차적 프로그래밍에서 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어렵다는 것이다.
- 절차적 프로그래밍은 프로세스가 필요한 모든 데이터를 의존해야 한다는 근본적인 문제점 때문에 변경에 취약할 수밖에 없다.
- 해결 방법은 프로세스의 적절한 단계를 Data로 이동시키는 것이다.
- 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식을 객체지향 프로그래밍(Object-Oriented Programming)이라 부른다.


책임의 이동
- 객체지향 설계에서는 독재자가 존재하지 않고, 각 객체에 책임이 적절하게 분배된다.
- 따라서 각 객체는 자신을 스스로 책임진다.

Bag 클래스 개선
- Bag을 Audience에 수동적이지 않은 자율적인 로직으로 개선
```java
public class Bag {  
    private Long amount;  
    private Invitation invitation;  
    private Ticket ticket;  
      
    public Long hold(Ticket ticket) {  
        if (hasInvitation()) {  
            setTicket(ticket);  
            return 0L;  
        } else {  
            setTicket(ticket);  
            minusAmount(ticket.getFee());  
            return ticket.getFee();  
        }  
    }  
  
    public boolean hasInvitation() {  
        return invitation != null;  
    }  
      
    public void setTicket(Ticket ticket) {  
        this.ticket = ticket;  
    }  
  
    public void minusAmount(Long amount) {  
        this.amount -= amount;  
    }  
}
```

TicketOffice 클래스 개선
```java
public class TicketOffice {  
    private Long amount;  
    private List<Ticket> tickets = new ArrayList<>();  
  
    public void sellTicketTo(Audience audience) {  
        plusAmount(audience.buy(getTicket()));  
    }  
  
    private Ticket getTicket() {  
        return tickets.remove(0);  
    }  
  
    private void plusAmount(Long amount) {  
        this.amount += amount;  
    }  
}

public class TicketSeller {  
  
    private TicketOffice ticketOffice;  
  
    public TicketSeller(TicketOffice ticketOffice) {  
        this.ticketOffice = ticketOffice;  
    }  
  
    public void sellTo(Audience audience) {  
        ticketOffice.sellTicketTo(audience);  
    }  
}
```


변경 코드의 문제점
- TicketOffice와 Audience 사이에 의존성이 추가
- 변경 전에는 TicketOffice가 Audience에 대해 알지 못했었는데, 변경 후에는 TicketOffice가 Audience에게 직접 티켓을 판매하기 때문에 의존성이 생김
- Audience에 대한 결합도와 TicketOffice의 자율성에 대한 Trade-off가 발생

의인화
- 현실에서 가방에서 돈을 꺼내는 것은 관람객이지 가방이 아니다.
- 소극장에 관람객이 입장하기 위해서도 누군가 소극장의 문을 열고 입장 허가를 해줘야 한다.
- 비록, 현실에서는 수동적인 존재라 하더라도 객체지향 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다.
- 레베카 워프스브룩은 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 가리켜 의인화(anthropomorphism)이라 부른다.


좋은 설계란 무엇인가?
- 우리가 짜는 프로그램은 두 가지 요구사항을 만족시켜야 한다.
- 기능을 구현하는 코드를 짜기 + 내일 쉽게 변경할 수 있는 코드를 짜기


Q. TicketOffice 개선하는 방법
- SOLID 5원칙 중 DIP(Dependency Inversion Principle)
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 의미
- 다음과 같은 Audience에 대한 인터페이스를 만들어 관리
```java
public interface Customer {
    Long buy(Ticket ticket);
}

public class Audience implements Customer {
    // Audience 클래스의 내용은 그대로 유지
}

public class TicketOffice {
    private Long amount;
    private List<Ticket> tickets = new ArrayList<>();

    public Long sellTicketTo(Customer customer) {
        return plusAmount(customer.buy(getTicket()));
    }

    private Ticket getTicket() {
        return tickets.remove(0);
    }

    private Long plusAmount(Long amount) {
        this.amount += amount;
        return this.amount;
    }
}

public class TicketSeller {

    private TicketOffice ticketOffice;

    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public void sellTo(Customer customer) {
        ticketOffice.sellTicketTo(customer);
    }
}

```


## 2장 객체지향 프로그래밍

영화 예매 시스템 구현

요구사항 #1
- 사용자는 영화 예매 시스템으로 영화를 예매
- '영화'는 영화에 대한 기본 정보를 표현한다. 제목, 상영시간, 가격 정보와 같이 영화가 가진 기본적인 정보를 가리킨다.
- '상영'은 실제로 관객들이 영화를 관람하는 사건을 표현
- 사용자가 실제로 예매하는 대상은 영화가 아니라 상영
- 특정한 조건을 만족하는 예매자는 요금을 할인받을 수 있음
- 할인액을 결정하는 두 가지 규칙이 존재
	- 할인조건(discount condition)
	- 할인 정책(discount policy)
- 할인 조건은 가격의 할인 여부를 결정하며, '순서 조건'과 '기간 조건'의 두 종류로 나뉨
- 순서 조건은 상영 순번을 이용해 할인 여부를 결정하는 규칙
- 기간 조건은 영화 상영 시간을 이용해 할인 여부를 결정
- 할인 정책은 할인 요금을 결정
- 할인 정책에는 '금액 할인 정책'과 '비율 할인 정책'이 있다.
- 금액 할인 정책은 예매 요금에서 일정 금액을 할인해주는 방식
- 비율 할인 정책은 정가에서 일정 비율의 요금을 할인해주는 방식
- 영화별로 하나의 할인 정책만 할당할 수 있고, 할인 정책을 지정하지 않는 것도 가능하다.
- 할인 조건은 다수의 할인 조건을 함께 지정할 수 있으며, 순서 조건과 기간 조건을 섞는 것도 가능하다.
- 할인을 적용하기 위해서는 할인 조건과 할인 정책을 함께 조합해서 사용
- 할인 조건을 만족하는지 먼저 확인하고 할인 조건을 만족할 경우 할인 정책을 이용해 할인 요금을 계산

어떤 클래스가 필요한가?
- 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민
- 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것
- 객체는 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 생각
- 객체는 홀로 존재하는 것이 아니다.

도메인(domain)
- 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라 한다.
![[영화예매도메인.png]]
- 영화 예매 도메인의 예시
- 일반적으로 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 유사하게 지어야 한다.


상영 클래스 구현
```java
public class Screening {  
    private Movie movie;  
    private int sequence;  
    private LocalDateTime whenScreened;  
      
    public Screening(Movie movie, int sequence, LocalDateTime whenScreened) {  
        this.movie = movie;  
        this.sequence = sequence;  
        this.whenScreened = whenScreened;  
    }  
      
    public LocalDateTime getStartTime() {  
        return whenScreened;  
    }  
      
    public boolean isSequence(int sequence) {  
        return this.sequence == sequence;  
    }  
      
    public Money getMovieFee() {  
        return movie.getFee();  
    }  
}
```
- 인스턴스 변수의 가시성은 private
- 메서드의 가시성은 public
- 외부에서는 객체의 속성에 직접 접근할 수 없도록 막고 적절한 public 메서드를 통해서만 내부 상태를 변경해야 한다.

자율적인 객체
- 객체는 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재이다.
- 객체는 스스로 판단하고 행동하는 자율적인 존재이다.
- 객체 안에 데이터와 기능을 함께 묶는 것을 캡슐화라고 부른다.
- 캡슐화에서 나아가, 외부에서 접근을 통제할 수 있는 접근제어(access control) 메커니즘도 함께 제공한다.
- 객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다.
- 객체가 자율적인 존재로 존재하기 위해서는 외부의 간섭을 최소화해야 한다.
- 외부에서는 객체가 어떤 상태에 놓여 있는지, 어떤 생각을 하고 있는지 알아선 안 된다.


캡슐화와 접근 제어
- 퍼블릭 인터페이스(public interface): 외부에서 접근 가능한 부분 
- 구현(implementation): 외부에서는 접근이 불가능하고 오직 내부에서만 접근 가능한 부분


협력
- 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청(request)
- 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답(response)
- 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것
- 다른 객체에게 요청이 도착할 때 해당 객체가 메시지를 수신했다고 표현
- 메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정
- 이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드라 부른다.


무비 클래스
```java
public class Movie {  
    private String title;  
    private Duration runningTime;  
    private Money fee;  
    private DiscountPolicy discountPolicy;  
  
    public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {  
        this.title = title;  
        this.runningTime = runningTime;  
        this.fee = fee;  
        this.discountPolicy = discountPolicy;  
    }  
  
    public Money getFee() {  
        return fee;  
    }  
  
    public Money calculateMovieFee(Screening screening) {  
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));  
    }  
}
```
- 해당 코드에는 어떤 할인 정책을 사용할 것인지 결정하는 코드가 없다.
- 단지, discountPolicy에게 메시지를 전송할 뿐이다.
- 위 코드에는 상속과 다형성 개념, 그리고 추상화 개념이 혼재되어 있다.

DiscountPolicy 클래스
```java
public class DiscountPolicy {  
    private List<DiscountCondition> conditions = new ArrayList<>();  
  
    public DiscountPolicy(DiscountCondition ... conditions) {  
        this.conditions = Arrays.asList(conditions);  
    }  
  
    public Money calculateDiscountAmount(Screening screening) {  
        for(DiscountCondition each : conditions) {  
            if (each.isSatisfiedBy(screening)) {  
                return getDiscountAmount(screening);  
            }  
        }  
  
        return Money.ZERO;  
    }  
  
    abstract protected Money getDiscountAmount(Screening screening);  
}
```
- DiscountPolicy는 DiscountCondition의 리스트인 conditions를 인스턴스 변수로 가진다.
- 때문에 하나의 할인 정책은 여러 개의 할인 조건을 포함할 수 있다.
- `calculatedDiscountAmount`메서드는 전체 할인 조건에 대해 차례로 `isSatisfiedBy` 메서드를 호출한다.
- 할인 조건을 만족하는 DiscountCondition이 하나라도 존재하는 경우 추상 메서드인 getDiscountAmount 메서드를 호출해 할인 요금을 계산한다.
- 만족하는 할인 조건이 하나도 존재하지 않는다면 할인 요금으로 0원을 반환한다.
- DiscountPolicy는 할인 여부와 요금 계산에 필요한 전체적인 흐름은 정의하지만 실제로 요금을 계산하는 부분은 추상 메서드인 getDiscountAmount 메서드에 위임한다.
- 실제로는 DiscountPolicy를 상속받은 자식 클래스에서 오버라이딩한 메서드가 실행될 것이다.
- 이처럼 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에 위임하는 디자인 패턴을 `Template Method 패턴` 이라 부른다.


할인 조건 클래스
```java
public interface DiscountCondition {  
    boolean isSatisfiedBy(Screening screening);  
}

public class SequenceCondition implements DiscountCondition {  
    private int sequence;  
  
    public SequenceCondition(int sequence) {  
        this.sequence = sequence;  
    }  
  
    public boolean isSatisfiedBy(Screening screening) {  
        return screening.isSequence(sequence);  
    }
}

public class PeriodCondition implements DiscountCondition{  
    private DayOfWeek dayOfWeek;  
    private LocalTime startTime;  
    private LocalTime endTime;  
  
    public PeriodCondition(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime){  
        this.dayOfWeek = dayOfWeek;  
        this.startTime = startTime;  
        this.endTime = endTime;  
    }  
      
    public boolean isSatisfiedBy(Screening screening){  
        return screening.getStartTime().getDayOfWeek().equals(dayOfWeek) &&  
            startTime.compareTo(screening.getStartTime().toLocalTime()) <= 0 &&  
            endTime.compareTo(screening.getStartTime().toLocalTime()) >= 0;  
    }  
}
```
- PeriodCondition은 상영 시간이 특정 기간 안에 포함되는지 여부를 판단해 할인 여부를 결정
- 조건에 사용할 요일(dayOfWeek), 시작 시간(startTime), 종료 시간(endTime)을 인스턴스 변수로 포함한다.
- `isSatisfied` 메서드는 인자로 전달된 Screening의 상영 요일이 dayOfWeek와 같고 상영 시작 시간이 startTime과 endTime 사이에 있을 경우 true를, 그렇지 않을 경우 false를 반환한다.


할인 정책 클래스
```java
public class AmountDiscountPolicy extends DiscountPolicy {  
    private Money discountAmount;  
  
    public AmountDiscountPolicy(Money discountAmount, DiscountCondition ... conditions) {  
        super(conditions);  
        this.discountAmount = discountAmount;  
    }
    
    @Override  
	protected Money getDiscountAmount(Screening screening) {  
	    return discountAmount;  
	}
}

public class PercentDiscountPolicy extends  DiscountPolicy {  
    private double percent;  
  
    public PercentDiscountPolicy(double percent, DiscountCondition ... conditions) {  
        super(conditions);  
        this.percent = percent;  
    }  
  
    @Override  
    protected Money getDiscountAmount(Screening screening) {  
        return screening.getMovieFee().times(percent);  
    }  
}


```


의존성
- 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다.
- 다시 말해 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.
- 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다.
- 즉, 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다.
- 반면 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아진다.


상속
- 객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법
- 상속을 이용하면 클래스 사이에 관계를 설정하는 것만으로 기존 클래스가 갖는 모든 속성과 행동을 새로운 클래스에 포함시킬 수 있다.
- 상속은 기존 클래스를 기반으로 새로운 클래스를 쉽고 빠르게 추가할 수 있다.
- 또한 부모 클래스의 구현은 공유하면서도 행동이 다른 자식 클래스를 쉽게 추가할 수 있다.
- 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 `차이에 의한 프로그래밍(programming by difference)`이라 한다.


상속과 인터페이스
- 상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려 받을 수 있기 때문이다.
- 이것은 상속을 바라보는 일반적인 인식, 즉 상속의 목적이 메서드나 인스턴스 변수를 재사용하는 것이라는 것과 거리가 있다.
- 인터페이스는 객체가 이해할 수 있는 메시지의 목록이다.
- 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 된다.
- 결과적으로 자식 클래스는 부모 클래스가 수신하는 모든 메시지를 수신할 수 있기 때문에 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다.
- 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅(upcasting)이라 부른다.
- 자식 클래스가 부모 클래스로 자동 타입 캐스팅이 되는 것처럼 동작하기 때문에 업캐스팅이라 부른다.


다형성
- 메시지와 메서드는 다른 개념이다.
	- Movie는 DiscountPolicy의 인스턴스에 메시지를 보낸다.
	- 그렇다면 실행되는 메서드는 무엇인가?
	- Movie와 상호작용하기 위해 연결된 객체의 클래스가 무엇인지에 따라 다르다.
- 즉, 객체는 동일한 메시지를 전송하지만, 실제로 어떤 메서드가 실행되는지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다.
- 이를 다형성이라 부른다.
- 다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다.
- 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다. 다시 말해 인터페이스가 동일해야 한다.
- 메시지와 메서드를 실행 시점에 바인딩하는 것을 지연 바인딩(lazy binding) 또는 동적 바인딩(dynamic binding)이라 한다.
- 그에 반해 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 초기 바인딩(early binding) 또는 정적 바인딩(static binding)이라 한다.


> 구현 상속과 인터페이스 상속
> 상속은 구현 상속과 인터페이스 상속으로 분류할 수 있다. 흔히 구현 상속을 서브클래싱(subclassing)이라 부르고 인터페이스 상속을 서브타이핑(subtyping)이라 부른다. 순수하게 코드를 재사용하기 위한 목적으로 상속을 구현하는 것을 구현 상속이라 하고, 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것을 인터페이스 상속이라 부른다.


인터페이스와 다형성
- 클래스를 상속할 때 구현은 공유할 필요가 없고 순수하게 인터페이스만 공유하고 싶을 때가 있다.
- 이럴 때 자바에서는 '인터페이스'라는 프로그래밍 요소를 제공한다.
- 자바의 인터페이스는 말 그대로 구현에 대한 고려 없이 다형적인 협력에 참여하는 클래스들이 공유 가능한 외부 인터페이스를 정의한 것이다.


추상화
- 추상화를 사용하면 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다.
- 추상화의 이런 특징은 세부사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요 개념을 설명할 수 있게 한다.
- 추상화를 이용해 상위 정책을 기술한다는 것은 기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미한다.
- 추상화를 이용해 상위 정책을 표현하면 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다.


코드 재사용
- 합성(composition)은 코드 재사용을 위해서 사용되는 방법
- 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말한다.
- 코드 재사용에는 상속 보다는 합성이 선호된다.


상속이 합성보다 안좋은 이유
- 상속은 두 가지 관점에서 설계에 안 좋은 영향을 미친다.
	- 하나는 상속이 캡슐화를 위반한다는 것
	- 다른 하나는 설계를 유연하지 못하게 만든다는 것
- 상속의 가장 큰 문제는 캡슐화를 위반한다는 것
	- 상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다.
	- 자식 클래스에서는 부모 클래스의 구현이 노출되기 때문에 캡슐화가 약화된다.
	- 캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률이 높다.
	- 결과적으로 상속을 과도하게 사용한 코드는 변경하기 어렵다.
- 상속의 두 번째 단점은 설계가 유연하지 않다는 것이다.
	- 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다.
	- 따라서 실행 시점의 객체의 종류를 변경하는 것이 불가능하다.

합성
- 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성이라고 부른다.
- 합성은 상속이 갖는 두 가지 문제점을 모두 해결한다.
	- 인터페이스에 정의된 메시지를 통해서만 재사용 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다.
	- 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다.


## 3장 역할, 책임, 협력


협력을 다시 정리
- 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 협력이라고 한다.
- 객체가 협력에 참여하기 위해 수행하는 로직은 책임이라고 한다.
- 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구현한다.
- 협력은 객체지향의 세계에서 기능을 구현하는 유일한 방법
- 두 객체 사이의 협력은 하나의 객체가 다른 객체에게 도움을 요청할 때 시작된다.
- `메시지 전송`은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단이다.
- 메시지를 수신한 객체는 메서드를 실행해 요청에 응답한다.
- 여기서 객체는 메시지를 처리할 방법을 스스로 선택한다.
- 즉, 외부의 객체는 오직 메시지만 전송할 수 있을 뿐이며 메시지를 어떻게 처리할지는 메시지를 수신한 객체가 직접 결정한다.


협력이 설계를 위한 문맥을 결정
- 객체란 상태와 행동을 함께 캡슐화하는 실행 단위
- 그렇다면 객체가 가질 수 있는 상태와 행동을 어떤 기준으로 결정해야 할까?
- 객체를 설계할 때 어떤 행동과 상태를 할당했다면 그 이유는 무엇인가?
- 애플리케이션 안에 어떤 객체가 필요하다면 그 이유는 단 하나여야 한다.
	- 그 객체가 어떤 협력에 참여하고 있다는 것
	- 그리고 객체가 협력에 참여할 수 있는 이유는 협력에 필요한 적절한 행동을 보유하고 있기 때문
- 결론적으로 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력
- 협력이 바뀌면 객체가 제공해야 하는 행동 역시 바뀌어야 한다.
- 협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다.
- 객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동이다.
- 객체의 상태는 그 객체가 행동을 수행하는 데 필요한 정보가 무엇인지로 결정된다.


책임이란 무엇인가
- 객체가 협력에 참여하기 위해 수행하는 행동을 `책임`이라 부른다.
- 책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합
- 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장
- 즉, 객체의 책임은 객체가 '무엇을 알고 있는가'와 '무엇을 할 수 있는가'로 구성된다.

```
하는 것
- 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것
- 다른 객체의 행동을 시작시키는 것
- 다른 객체의 활동을 제어하고 조절하는 것

아는 것
- 사적인 정보에 관해 아는 것
- 관련된 객체에 관해 아는 것
- 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것
```

책임
- 협력 안에서 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정한다.
- 일반적으로 책임과 메시지의 크기는 다르다.
	- 책임은 객체가 수행할 수 있는 행동을 종합적이고 간략하게 서술
	- 때문에 메시지보다 추상적이로 개념적으로 크다
	- 처음에는 단순한 책임도 여러 개의 메시지로 분할되거나 하나의 객체가 수행할 수 있다고 생각했던 책임이 나중에 여러 객체들이 협력해야 하는 커다란 책임이 될 수 있다.
- 책임의 관점에서 '아는 것'과 '하는 것'은 밀접하게 연관돼 있다.
	- 객체는 자신이 맡은 책임을 수행하는 데 필요한 정보를 알고 있을 책임이 있다.
	- 객체는 자신이 할 수 없는 작업을 도와줄 객체를 알고 있을 책임이 있다.
	- 어떤 책임을 수행하기 위해서는 그 책임을 수행하는 데 필요한 정보도 함께 알아야 할 책임이 있다.
- 책임은 객체지향 설계의 핵심이다.
- 적절한 협력이 적절한 책임을 제공하고, 적절한 책임을 적절한 객체에게 할당해야만 단순하고 유연한 설계를 창조할 수 있다.


책임 할당
- 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것
- 이를 책임 할당을 위한 `Information Expert(정보 전문가)`패턴이라 부른다.
- 객체지향 설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이루어진다.
- 그리고 이런 메시지가 메시지를 수신할 객체의 책임을 결정한다.
- 이렇게 결정된 메시지가 객체의 퍼블릭 인터페이스를 구성한다는 것도 중요하다
- 협력을 설계하면서 객체의 책임을 식별해 나가는 과정을 통해 시스템을 구성하는 객체들의 인터페이스와 오퍼레이션 목록을 얻을 수 있다.


책임 주도 설계
- 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 '책임 주도 설계(Responsibility-Driven Design, RDD)'이라 부른다.
- 책임 주도 설계 방법의 과정
	- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
	- 시스템 책임을 더 작은 책임으로 분할한다.
	- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
	- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적잘한 객체 또는 역할을 찾는다.
	- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.
- 책임을 할당할 때 고려해야 하는 두 가지 요소
	- 메시지가 객체를 결정한다는 것
	- 행동이 상태를 결정한다는 것


메시지가 객체를 결정한다.
- 객체에게 책임을 할당하는 데 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 선택하게 된다.
- 다시 말해 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택한다.
- 메시지가 객체를 선택하게 하는 두 가지 중요한 이유
	- 객체가 최소한의 인터페이스(minimal interface)를 가질 수 있게 된다.
		- 필요한 메시지가 식별될 때까지 객체의 퍼블릭 인터페이스에 어떤 것도 추가하지 않기 때문에 객체는 애플리케이션에 적절한 크기의 퍼블릭 인터페이스를 가질 수 있다.
	- 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다.
		- 객체의 인터페이스는 무엇(what)을 하는지는 표현해야 하지만 어떻게(how) 수행하는지는 노출해선 안된다.
		- 메시지는 외부의 객체가 요청하는 무언가를 의미하기 때문에 메시지를 먼저 식별하면 무엇을 수행할지에 초점을 맞추는 인터페이스를 얻을 수 있다.


행동이 상태를 결정한다.
- 객체는 협력에 필요한 행동을 제공해야 한다.
- 객체의 행동은 객체가 협력에 참여할 수 있는 유일한 방법이다.
- 객체가 협력에 적합한지를 결정하는 것은 그 객체의 상태가 아니라 행동이다.
- 얼마나 적절한 객체를 창조했느냐는 얼마나 적절한 책임을 할당했느냐에 달려있고, 책임이 얼마나 적절한지는 협력이 얼마나 적절한가에 달려있다.
- 초보자들이 하는 객체의 상태에 초점을 두어 설계하는 방법을 '데이터-주도 설계(Data-Driven Design)'라고 부른다.
- 캡슐화를 위반하지 않도록 구현에 대한 결정을 뒤로 미루면서 객체의 행위를 고려하기 위해서는 항상 협력이라는 문맥 안에서 객체를 생각해야 한다.
- 협력 관계 속에서 다른 객체에게 무엇을 제공해야 하고 다른 객체로부터 무엇을 얻어야 하는지를 고민해야만 훌륭한 책임을 수확할 수 있다.
- 개별 객체의 상태와 행동이 아닌 시스템의 기능을 구현하기 위한 협력에 초점을 맞춰야만 응집도가 높고 결합도가 낮은 객체들을 창조할 수 있다.
- 상태는 단지 객체가 행동을 정상적으로 수행하기 위해 필요한 재료이다.



역할과 협력
- 객체는 협력이라는 주어진 문맥 안에서 특정한 목적을 갖는다.
- 객체의 목적은 협력 안에서 객체가 맡게 되는 책임의 집합으로 표시된다.
- 이처러 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 '역할'이라 부른다.
- 실제로 협력을 모델링할 때는 특정 객체가 아닌 역할에 책임을 할당한다고 생각하는게 좋다.


유연하고 재사용 가능한 협력
- 역할이 중요한 이유는 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있기 때문이다.
- ex) 영화 예매 시스템에서 할인 정책이 두 가지 존재한다고 가정했을 때
	- 두 가지 종류의 객체가 할인 요금을 계산하라는 메시지에 응답할 수 있어야 한다.
	- 그렇다면 두 종류의 객체가 참여하는 협력을 개별적으로 만들어야 하나?
	- 위의 방식은 코드 중복의 문제를 야기한다.
- 문제를 해결하기 위해서는 객체가 아닌 '책임'에 초점을 맞춰야 한다.
- 순수하게 책임의 관점에서 두 할인정책은 모두 '할인 요금 계산'이라는 동일한 책임을 수행한다.
- 따라서 객체라는 존재를 지우고 할인 요금을 계산하라는 메시지에 응답할 수 있는 대표자를 생각해보면 두 협력을 하나로 통합할 수 있다.
- 이 대표자를 협력 안에서 두 종류의 객체를 교대로 바꿔 끼울 수 있는 일종의 슬롯이라 생각하면, 이 슬롯이 바로 '역할'이다.
- 요점은 동일한 책임을 수행하는 역할을 기반으로 두 개의 협력을 하나로 통합할 수 있다는 것
- 따라서 역할을 이용하면 불필요한 코드 중복을 제거할 수 있다.
- 또한 협력을 더 유연하게 만든다.
	- 새로운 할인 정책이 추가되어도 협력에 참여할 수 있다.



역할의 구현
- 역할을 구현하는 가장 일반적인 방법은 '추상 클래스'와 '인터페이스'를 사용하는 것
- 협력의 관점에서 추상 클래스와 인터페이스는 구체 클래스들이 따라야 하는 책임의 집합을 서술한 것
- 추상 클래스는 책임의 일부를 구현해 놓은 것이고 인터페이스는 일체의 구현 없이 책임의 집합만을 나열해 놓았다는 차이가 있지만 협력의 관점에서는 둘 모두 역하을 정의할 수 있는 구현 방법이라는 공통점이 있다.


객체 대 역할
- 역할은 객체가 참여할 수 있는 일종의 슬롯
- 그러나 오직 한 종류의 객체만 협력에 참여하는 상황에서 역할이라는 개념을 고려하는 것이 유용할까?
	- 레베카 워브스브록 왈 "단지 한 종류의 객체만이 협력에 참여할 필요가 있다면 후보는 객체가 된다."
	- 다시 말해 협력에 적합한 책임을 수행하는 대상이 한 종류라면 간단하게 객체로 간주한다.
- 만약 여러 종류의 객체들이 참여할 수 있다면 역할이라고 부르면 된다.


역할과 추상화
- 역할은 공통의 책임을 바탕으로 객체의 종류를 숨기기 때문에 이런 관점에서 역할을 객체의 추상화로 볼 수 있다.
- 추상화 장점 첫 번째
	- 세부 사항에 억눌리지 않고도 상위 수준의 정책을 쉽고 간단하게 표현할 수 있다.
	- 적절한 추상화는 불필요한 세부 사항을 생략하고 핵심적인 개념을 강조한다.
	- 협력 관점에서는 세부적인 사항을 무시하고 추상화에 집중하는 것이 유용하다.
	- 객체에게 중요한 것은 행동으로, 역할이 중요한 이유는 동일한 협력을 수행하는 객체들을 추상화 할 수 있기 때문이다.
- 추상화 장점 두 번째
	- 설계를 유연하게 만든다.
	- 협력 안에서 동일한 책임을 수행하는 객체들은 동일한 역할을 수행하기 때문에 서로 대체 가능하다
	- 역할은 다양한 환경에서 다양한 객체들을 수용할 수 있게 해준다.


## 4장 설계 품질과 트레이드오프

객체지향 설계의 핵심
- 객체지향 설계의 핵심은 역할, 책임, 협력
	- 협력: 애플리케이션 기능을 구현하기 위해 메시지를 주고받는 객체들 사이의 상호작용
	- 책임: 객체가 다른 객체와 협력하기 위해 수행하는 행동
	- 역할: 대체 가능한 책임의 집합
- 역할, 책임, 협력 중 가장 중요한 것은 '책임'
	- 객체들이 수행할 책임이 적절하지 않으면 원활한 협력을 할 수 없다.
	- 역할은 책임의 집합으로 책임이 적절하지 못하면 협력과 조화를 이루지 못한다.
- 즉, 책임이 객체지향 애플리케이션 전체의 품질을 결정한다.


결합도와 응집도를 합리적인 수준으로 유지하는 원칙
- 객체의 상태가 아니라 객체의 행동에 초점을 맞춘다.
- 객체를 단순한 데이터 집합으로 바라보면 객체의 내부 구현을 인터페이스에 노출시키는 결과를 낳는다.
- 객체의 책임의 초점을 맞추면 객체의 상태에서 행동으로, 또 객체와 객체 사이의 상호작용으로 설계 중심을 이동할 수 있다.
- 책임의 초점을 맞추면 결합도가 낮고 응집도가 높으며 구현을 효과적으로 캡슐화하는 객체들을 창조할 수 있다.


캡슐화
- 상태와 행동을 하나의 객체 안에 모으는 이유는 객체 내부 구현을 외부로부터 감추기 위해서
- 구현이란 나중에 변경될 가능성이 높은 어떤 것
- 객체지향은 한 곳에서 일어난 변경이 시스템 전체에 영향을 끼치지 않도록 파급효과를 적절하게 조절하는 장치를 제공
- 객체는 변경 가능성이 높은 부분은 내부에 숨기고, 외부에는 상대적으로 안정적인 부분만 공개함으로써 변경의 여파를 통제함
- 구현: 변경될 가능성이 높은 부분
- 인터페이스: 상대적으로 안정적인 부분
- 캡슐화
	- 외부에서 알 필요가 없는 부분을 감춰 대상을 단순화하는 추상화의 한 종류
	- 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법


응집도와 결합도
응집도
- 모듈에 포함된 내부 요소들이 연관된 정도
- 모듈 내의 요소들이 하나의 목적을 위해 긴밀히 협력하면 그 모듈은 높은 응집도 를 가진다.
- 객체지향 관점에서 응집도는 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다.

결합도
- 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도
- 어떤 모듈이 다른 모듈에 대해 꼭 필요한 지식만 알고 있다면 두 모듈은 낮은 결합도를 갖는다.
- 객체지향 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타낸다.

높은 응집도와 낮은 결합도를 유지해야 하는 이유?
- 높은 응집도와 낮은 결합도는 설계를 변경하기 쉽게 만들기 때문

응집도 측정 방법
- 변경 관점에서 응집도는 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다.
- 즉, 하나의 변경에 모듈의 수정되는 정도에 따라 응집도가 결정된다.
![[응집도.png]]
- 높은 응집도는 하나의 변경에 하나의 모듈만 수정
- 낮은 응집도는 하나의 변경에 여러 모듈을 수정


결합도 측정 방법
- 한 모듈이 변경되기 위해 다른 모듈의 변경을 요구하는 정도
- 하나의 모듈을 수정할 때 얼마나 많은 모듈을 함께 수정해야 하는지를 나타낸다.
- 결합도가 높으면 변경해야 하는 모듈 수도 늘어난다.
![[결합도.png]]


결합도가 높아도 상관없는 경우
- 변경될 확률이 매우 적은 안정적인 모듈에 의존하는 것
- 표준 라이브러리에 포함된 모듈이나 성숙 단계에 접어든 프레임워크에 의존하는 경우



접근자와 수정자를 사용하면 캡슐화가 가능한가?
- 답: X
- 접근자와 수정자는 어떤 인스턴스 변수가 존재하는지 퍼블릭 인터페이스에 노골적으로 드러낸다.
	- 예시) getName, setName이라는 퍼블릭 인터페이스는 'name'이라는 인스턴스 변수가 있는 것을 드러냄
- 객체가 사용될 문맥을 추측할 수밖에 없는 경우 개발자는 어떤 상황에서도 해당 객체가 사용될 수 있게 최대한 많은 접근자 메서드를 추가하게 된다.
	- 이처럼 접근자와 수정자에 과도하게 의존하는 설계 방식을 '추측에 의한 설계 전략(design-by-guessing strategy)'이라 부른다.


접근자로 캡슐화가 불가능한 이유
- 예시)
```java
public class Movie
	public Money getFee() {  
	    return fee;  
	}  
  
	public void setFee(Money fee) {  
	    this.fee = fee;  
	}
//...(생략)
end

public class ReservationAgency {
	public Reservation reserve(Screening screening, Customer customer, int audienceCount) {
	...
	Money fee;
	if(discountable) {
		...
		fee = movie.getFee().minus(discountedAmount).times(audienceCount);
	} else {
		fee = movie.getFee();
	}

	...
}
```
- 위 코드 예시에서 'fee'의 데이터 타입이 변경된다면?
	- getFee의 메서드 반환 타입이 변경되어야 함
	- getFee 메서드를 호출하는 ReservationAgency의 구현도 변경된 타입에 맞게 수정되어야 함
	- fee의 타입 변경으로 협력하는 클래스가 변경된다는 것은 getFee 메서드는 fee를 정상적으로 캡슐화하지 못한다는 것을 의미
- getFee 메서드를 사용하는 것은 인스턴스 변수 fee의 가시성을 private에서 public으로 변경하는 것과 거의 동일


캡슐화를 지켜라
```java
class Rectangle {  
    private int left;  
    private int top;  
    private int right;  
    private int bottom;  
      
    public Rectangle(int left, int top, int right, int bottom) {  
        this.left = left;  
        this.top = top;  
        this.right = right;  
        this.bottom = bottom;  
    }  
      
    public int getLeft() { return left; }  
    public void setLeft(int left) { this.left = left; }  
      
    public int getTop() { return top; }  
    public void setTop(int top) { this.top = top; }  
      
    public int getRight() { return right; }  
    public void setRight(int right) { this.right = right; }  
      
    public int getBottom() { return bottom; }  
    public void setBottom(int bottom) { this.bottom = bottom; }  
}
```
- 예시) 사각형을 표현하는 간단한 클래스
- Recatangle은 사각형의 좌표들을 포함하고 각 속성에 대한 접근자와 수정자 메서드를 제공
- 이 사각형의 너비와 높이를 증가시키는 코드가 필요하다고 가정했을 때, 아마 이 코드는 Rectangle 외부의 어떤 클래스 안에 다음과 같이 구현돼 있을 것이다.
```java
class AnyClass {
	void anyMethod(Rectangle rectangle, int multiple) {
		rectangle.setRight(rectangle.getRight() * multiple);
		rectangle.setBottom(rectangle.getBottom() * multiple);
	}
}
```
- 위 코드의 문제점 1 : 코드 중복이 발생할 확률이 높다.
	- 다른 곳에서도 사각형의 너비와 높이를 증가시키는 코드가 필요하다면 똑같은 코드를 중복 호출해야 한다.
- 위 코드의 문제점 2 : 변경에 취약하다.
	- Rectangle이 right와 bottom 대신 length와 height을 이용해서 사각형을 표현하도록 수정한다고 가정하면 기존 접근자 메서드를 사용하던 모든 코드를 수정해야 한다.
- 해결 방법 : 캡슐화를 강화
- 예시)
```java
class Rectangle {
	public void enlarge(int multiple) {
		right *= multiple;
		bottom *= multiple;
	}
}
```
- Rectangle을 변경하는 주체를 외부의 객체에서 Rectangle로 이동
- 즉, 객체가 자기 스스로 책임지게 변경됨


스스로 자신의 데이터를 책임지는 객체
- "이 객체가 어떤 데이터를 포함해야 하는가?"라는 질문은 다음과 같이 분리
	- 이 객체가 어떤 데이터를 포함해야 하는가?
	- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?


캡슐화 위반
```java
public class DiscountCondition {
	private DiscountConditionType type;
	private int sequence;
	private DayOfWeek dayOfWeek;
	private LocalTime startTime;
	private LocalTime endTime;

	public DiscountConditionType getType() { ... }
	public boolean isDiscountable(DayOfWeek dayOfWeek, LocalTime time) { ... }
	public boolean isDiscountable(int sequence) { ... }
}
```
- 위 코드의 캡슐화 문제점
- `isDiscountable` 메서드의 시그니처를 보면 'DiscountCondition'에 속성으로 포함된 'DayOfWeek' 타입과 'LocalTime' 타입을  파라미터로 받는 것을 알 수 있다.
- 이 메서드는 객체 내부에 위 두 타입의 인스턴스 변수가 포함돼 있다는 사실을 인터페이스를 통해 외부에 노출하고 있는 것
- 또 하나의 문제는  'setType' 메서드는 없지만 'getType' 메서드를 통해 내부에 'DiscountConditionType'을 포함하고 있다는 정보를 노출하는 것
- DiscountCondition의 속성을 변경해야 한다면?
	- isDiscountable 메서드의 파라미터를 수정
	- 해당 메서드를 사용하는 모든 클라이언트도 함께 수정
- 이처럼 내부 구현의 변경이 외부로 퍼져나가는 **파급 효과(ripple effect)** 는 캡슐화가 부족하다는 증거



> Q. 인스턴스 변수가 포함되어 있다고 단언할 수 있는가?
> 변수의 파라미터로 받아서 메서드 내부에서 단순 활용될 수도 있지 않나?


그렇다면 메서드 시그니처를 통해 객체 인스턴스 변수를 노출시키지 않는다면?
예시)
```java
public class Movie {  
    private String title;  
    private Duration runningTime;  
    private Money fee;  
    private List<DiscountCondition> discountConditions;  
      
    private MovieType movieType;  
    private Money discountAmount;  
    private double discountPercent;  
      
    public MovieType getMovieType() { ... }  
    public Money calculateAmountDiscountedFee() { ... }  
    public Money calculatePercentDiscountedFee() { ... }  
    public Money calculateNoneDiscountedFee() { ... }
```
- 위 'Movie' 클래스는 메서드 시그니처나 반환 값으로 내부에 포함된 속성에 대한 어떤 정보도 노출하지 않는다.
- 그렇다면 캡슐화의 원칙을 지키고 있는 것일까? X
- 위 클래스는 할인 정책의 종류를 노출한다.
- 'calculateAmountDiscountedFee', 'calculatePercentDiscountedFee', 'calculateNoneDiscountedFee' 세 개의 메서드는 할인 정책에 세 가지 정책이 존재한다는 사실을 드러낸다.
- 만약 새로운 할인 정책이 추가되거나 제거된다면 이 메서드에 의존하는 모든 클라이언트가 영향을 받게 된다.
- 따라서 Movie는 세 가지 할인 정책을 포함하고 있다는 내부 구현을 성공적으로 캡슐화하지 못한다.


> 캡슐화의 진정한 의미
> 캡슐화는 단순히 객체 내부의 데이터를 외부로부터 감추는 것 이상의 의미를 갖는다.
> 사실 캡슐화는 변경될 수 있는 어떤 것이라도 감추는 것을 의미한다. 내부 속성을 외부로부터 감추는 것은 '데이터 캡슐화'라고 불리는 캡슐화의 한 종류이다.
> 내부 구현의 변경으로 인해 외부의 객체가 영향을 받는다면 캡슐화를 위반하는 것이다. 설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화해야 한다.


데이터 중심 설계의 문제점

데이터 중심 설계가 변경에 취약한 이유
- 너무 이른 시기에 데이터에 관해 결정하도록 강요
- 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정


체크리스트
1. 코드 중복이 발생할 가능성이 높은가?
2. 메서드 시그니처나 리턴값을 통해 외부에서 클래스 인스턴스 변수를 파악할 수 있는가?
3. 메서드를 통해 해당 클래스 정책 종류를 모두 파악할 수 있는가?
4. 클래스의 정책이 변경됐을 때 수정해야 하는 외부 코드가 많은가?


5장

책임 중심 설계를 지키기 위해 지켜야 할 원칙
- 데이터보다 행동을 먼저 결정하라
- 협력이라는 문맥 안에서 책임을 결정하라


책임 할당을 위한 GRASP 패턴

GRASP 패턴
- General Responsibility Assignment Software Pattern
- 일반적인 책임 할당을 위한 소프트웨어 패턴
- 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리

도메인 개념에서 출발
- 어떤 책임을 할당해야 할 때 가장 먼저 고민해야 하는 유력한 후보는 바로 도메인 개념
- 설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요 없다.
- 이 단계에서는 책임을 할당받을 객체들의 종류와 관계에 대한 유용한 정보를 제공할 수 있다면 충분


정보 전문가에게 책임을 할당
- 책임 주도 설계 방식의 첫 단계는 애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각하는 것
- 이 책임을 애플리케이션에 대해 전송된 메시지로 간주하고 이 메시지를 책임질 첫 번째 객체를 선택하는 것으로 설계를 시작
- 첫 번째 질문: "메시지를 전송할 객체는 무엇을 원하는가?"
- 두 번째 질문: "메시지를 수신할 적합한 객체는 누구인가?"
- 객체의 책임과 책임을 수행하는 데 필요한 상태는 동일 객체 안에 존재해야 한다.
- 객체에게 책임을 할당하는 첫 번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것
- GRASP에서는 이를 'INFORMATION EXPERT'(정보 전문가) 패턴이라고 부른다.

> INFORMATION EXPERT 패턴
- 정보와 행동을 최대한 가까운 곳에 위치
- 캡슐화를 유지함으로써 응집력 있고 결합도가 낮은 코드 구현이 가능
- 유지보수가 쉬운 시스템을 구축할 수 있음


Q. 여기서 이야기하는 정보는 데이터인가?
- 여기서 정보는 데이터와 다르다
- 책임을 수행하는 객체가 정보를 알고 있다고 해서 그 정보를 저장할 필요는 없다.
- 객체는 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나 필요한 정보를 계산해서 제공할 수 있다.


높은 응집도와 낮은 결합도
- 협력 패턴이 여러 개라면 높은 응집도와 낮은 결합도를 가진 패턴을 선택해야 한다.
- GRASP에서는 이를 'LOW COUPLING'(낮은 결합도) 패턴과 'HIGH COHESION'(높은 응집도) 패턴이라 부른다.


창조자에게 객체 생성 책임을 할당
- GRASP의 'CREATOR(창조자)' 패턴
- 책임 할당 패턴으로서 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공


>CREATOR 패턴
- 객체 A를 생성해야 할 때 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당
	- B가 A 객체를 포함하거나 참조
	- B가 A 객체를 기록
	- B가 A 객체를 긴밀하게 사용
	- B가 A 객체를 초기화하는데 필요한 데이터를 가지고 있다.


변경 파악
- 코드를 통해 변경의 이유를 파악할 수 있는 첫 번째 방법
	- 인스턴스 변수가 초기화되는 시점을 살펴보는 것
	- 응딥도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다.
	- 반면 응집도가 낮은 클래스는 객체의 속성 중 일부만 초기화하고 일부는 초기화되지 않은 상태로 남겨진다.
- 코드를 통해 변경의 이유를 파악할 수 있는 두 번째 방법
	- 메서드들이 인스턴스 변수를 사용하는 방식을 살펴보는 것
	- 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다.
	- 반면 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮은 것


클래스 응집도 판단하기
- 클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은 것이다. 변경의 이유를 기준으로 클래스를 분리하라
- 클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다면 응집도가 낮은 것이다. 초기화되는 속성의 그룹을 기준으로 클래스를 분리하라
- 메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 낮은 것이다. 이들 그룹을 기준으로 클래스를 분리하라


분리된 클래스를 구현하는 법
- '역할'의 개념을 통해 다형성을 적용해 클래스를 분리
- 자바에서는 일반적으로 역할을 구현하기 위해 추상 클래스나 인터페이스를 사용
- 역할을 대체할 클래스들 사이에서 구현을 공유해야 할 필요가 있다면 '추상 클래스' 사용
- 구현을 공유할 필요 없이 역할을 대체하는 객체들의 책임만 정의하고 싶다면 '인터페이스' 사용
- 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당
- GRASP에서는 이를 'POLYMORPHISM(다형성)' 패턴이라 부른다.


PROTECTED VARIATIONS(변경 보호) 패턴
- 변경을 캡슐화하도록 책임을 할당하는 것
- 설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화하는 것
- 변경이 될 가능성이 높다면 캡슐화한다.



응집도가 낮은 메서드
- 로직의 흐름을 이해하기 위해 주석이 필요한 경우가 대부분
- 메서드가 명령문들의 그룹으로 구성되고 각 그룹에 주석을 달아야 할 필요가 있다면 그 메서드의 응집도는 낮은 것
- 주석을 추가하는 대신 메서드를 작게 분해해 각 메서드의 응집도를 높이는 것이 좋다.
- 응집도 높은 메서드는 재사용이 쉽고 코드 이해가 쉽다.


6장

클라이언트-서버 모델
- 두 객체 사이의 협력 관계를 설명하기 위해 사용하는 전통적인 메타포
- 협력 안에서 메시지를 전송하는 객체를 클라이언트, 메시지를 수신하는 객체를 서버라고 부른다.
- 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용
- 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적
- 협력의 관점에서 객체는 두 가지 종류의 메시지 집합으로 구성된다.
	- 하나는 객체가 수신하는 메시지의 집합
	- 다른 하나는 외부의 객체에게 전송하는 메시지의 집합


메시지와 메시지 전송
- 메시지 전송: 한 객체가 다른 객체에게 도움을 요청하는 것
- 메시지 전송자: 메시지를 전송하는 객체
- 메시지 수신자: 메시지를 수신하는 객체
- 메시지는 '오퍼레이션명'과 '인자'로 구성, 메시지 전송은 여기에 '메시지 수신자'를 추가한 것
- 즉, 메시지 전송은 메시지 수신자, 오퍼레이션명, 인자의 조합


![[언어별메시지전송예시.png]]


메시지와 메서드
- 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 '메서드'라고 부른다.
- 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.
- 메시지 전송자는 자신이 어떤 메시지를 전송해야 하는지만 알면 된다.
- 메시지 수신자는 누가 메시지를 전송하는지 알 필요가 없다.
- 단지 메서드가 도착했다는 사실을 알면 되고, 메시지 처리를 위해 필요한 메서드를 스스로 결정할 자율권을 누린다.


퍼블릭 인터페이스와 오퍼레이션
- 퍼블릭 인터페이스: 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합
- 오퍼레이션: 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지
- 오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화
- 흔히 오퍼레이션이라고 부를 때는 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분
- 메시지를 수신했을 때 실제로 실행되는 코드는 메서드
- 프로그래밍 언어의 관점에서 객체가 다른 객체에 메시지를 전송하면 런타임 시스템은 메시지 전송을 오퍼레이션 호출로 해석하고 메시지를 수신한 객체의 실제 타입을 기반으로 적절한 메서드를 찾아 실행
- 퍼블릭 인터페이스와 메시지 관점에선 '메서드 호출'보다는 '오퍼레이션 호출' 용어가 더 적절


시그니처
- 오퍼레이션의 이름과 파라미터 목록을 합쳐 시그니처라고 부른다.
- 오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것
- 메서드는 이 시그니처에 구현을 더한 것


인터페이스와 설계 품질
- 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야 함
- 최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함
- 추상적인 인터페이스는 어떻게 수행하는지가 아니라 무엇을 하는지를 표현
- 최소주의를 따르면서 추상적인 인터페이스를 설계하는 가장 좋은 방법은 '책임 주도 설계'


퍼블릭 인터페이스의 품질에 영향을 미치는 요소들
- 디미터 법칙
- 묻지 말고 시켜라
- 의도를 드러내는 인터페이스
- 명령-쿼리 분리


디미터 법칙
- 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것
- '낯선 자에게 말하지 말라' 또는 '오직 인접한 이웃하고만 말하라' 혹은 자바에서는 '오직 하나의 도트만 사용하라'
- 예시)
	- 모든 클래스 C와 C에 구현된 모든 메서드 M에 대해서, M이 메시지를 전송할 수 있는 모든 객체는 다음에 서술된 클래스의 인스턴스여야 한다.
	- 이때 M에 의해 생성된 객체나 M이 호출하는 메서드에 의해 생성된 객체, 전역 변수로 선언된 객체는 모두 M의 인자로 간주
		- M의 인자로 전달된 클래스(C 자체를 포함)
		- C의 인스턴스 변수의 클래스
	- 클래스 내부의 메서드가 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍
		- this 객체
		- 메서드의 매개변수
		- this의 속성
		- this의 속성인 컬렉션의 요소
		- 메서드 내에서 생성된 지역 객체
- 디미터 법칙을 따르면 부끄럼타는 코드(shy code)를 작성할 수 있다.
- 부끄럼타는 코드란 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다.
- 코드는 메시지 수신자의 내부 구조가 전송자에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다.


> 디미터 법칙과 캡슐화
- 디미터 법칙은 클래스를 캡슐화하기 위해 따라야 하는 구체적인 지침을 제공한다.
- 캡슐화 원칙이 클래스 내부의 구현을 감춰야 한다는 사실을 강조한다면 디미터 법칙은 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한한다.


디미터 법칙을 위반하는 코드의 전형적인 모습
```java
screening.getMovie().getDiscountConditions();
```
- 메시지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메시지를 전송한다.
- 이와 같은 코드를 기차 충돌(train wreck)이라 부른다.
- 기차 충돌은 클래스의 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태
- 메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게 된다.
- 따라서 메시지 수신자의 캡슐화는 무너지고, 메시지 전송자가 메시지 수신자의 내부 구현에 강하게 결합된다.
```java
screening.calculateFee(audienceCount);
```
- 위처럼 디미터 법칙을 따르도록 코드를 개선하면 메시지 전송자는 더 이상 메시지 수신자의 내부 구조에 관해 묻지 않게 된다.
- 하지만 무비판적으로 디미터 법칙을 수용하면 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수 있다.
- 디미터 법칙은 객체의 내부 구조를 묻는 메시지가 아니라 수신자에게 무언가를 시키는 메시지가 더 좋은 메시지라는 의미를 전달한다.


묻지 말고 시켜라
- 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안 된다.
- 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.
- 묻지 말고 시켜라 원칙에 따르도록 메시지를 결정하다 보면 자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻을 확률이 높아진다.


의도를 드러내는 인터페이스
- 메서드를 명명하는 두 가지 방법
	- 첫 번째 방법: 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는 것
	- 두 번째 방법: '어떻게'가 아니라 '무엇'을 하는지를 드러내는 것


```java
public class PeriodCondition {
	public boolean isSatisfiedByPeriod(Screening screening) { ... }
}

public class SequenceCondition {
	public boolean isSatisfiedBySequence(Screening screening) { ... }
}
```

위 예시 메서드의 문제점
- 메서드에 대해 제대로 커뮤니케이션하지 못한다. 클라이언트 관점에서 isSatisfiedByPeriod와 isSatisfiedBySequence 모두 할인 조건을 판단하는 동일한 작업을 수행한다. 하지만 메서드의 이름이 다르기 때문에 두 메서드의 내부 구현을 정확하게 이해하지 못한다면 두 메서드가 동일한 작업을 수행한다는 사실을 알아채기 어렵다.
- 더 큰 문제는 메서드 수준에서 캡슐화를 위반한다는 것이다. 




출처: 오브젝트

연결문서
