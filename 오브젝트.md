# 오브젝트 정리_01장
---

날짜: 2024-01-11
태그: #오브젝트
메모:

> 패러다임이란?
> 모델(model), 패턴(pattern), 또는 전형적인 예(example)를 의미하는 그리스어인 '파라데이그마(paradeigma)'에서 유래, 패러다임은 하나의 예를 복사하도록 허용


패러다임 전환(Paradigm Shift)
- 우주를 보는 관점이 천동설에서 지동설로 변화한 사건이 패러다임 전환이 대표 예
- 오브젝트 책에서는  '절차형 패러다임'에서 '객체지향 패러다임'으로 변화를 의미

프로그래밍 패러다임이 필요한 이유
- 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유할 수 있게 함으로써 불필요한 부분에 대한 의견 충돌을 방지
- 프로그래밍 패러다임을 교육시킴으로써 동일한 규칙과 방법을 공유하는 개발자로 성장할 수 있도록 준비

다중패러다임 언어(Multiparadigm Language)
- 하나 이상의 패러다임을 수용하는 언어
- 함수형 패러다임과 객체지향 패러다임을 접목한 스칼라(Scala) 등이 예시


---

티켓 판매 애플리케이션 구현하기

요구사항
- 추첨을 통해 선정된 관람객에게 공연을 무료로 관람할 수 있는 초대장을 발송
- 초대되지 못한 관람객을 티켓을 구매해야만 입장할 수 있음
- 따라서, 관람객을 입장시키기 전에 이벤트 당첨 여부를 확인해야 하고, 이벤트 당첨자가 아닌 경우 티켓을 판매 후 입장시켜야 함

Invitation Class
```Java
public class Invitation {
	private LocalDateTime when;
}
```
- 공연을 관람할 수 있는 초대일자(when)를 인스턴스 변수로 포함하는 간단한 클래스

Ticket Class
```Java
public class Ticket {  
    private Long fee;  
      
    public Long getFee() {  
        return fee;  
    }  
}
```
- 공연을 관람하기 원하는 모든 사람들은 티켓을 소지하고 있어야만 한다.

요구사항 #2
- 이벤트 당첨자는 티켓으로 교환할 초대장을 가지고 있고, 이벤트에 당첨되지 않은 관람객은 티켓을 구매할 현금을 보유하고 있다.
- 따라서 관람객이 가지고 올 수 있는 소지품은 초대장, 현금, 티켓 세 가지뿐이다.
- 관람객은 소지품을 보관할 용도로 가방을 들고 올 수 있다.

Bag Class
```Java
public class Bag {  
    private Long amount;  
    private Invitation invitation;  
    private Ticket ticket;  
      
    public boolean hasInvitation() {  
        return invitation != null;  
    }  
      
    public boolean hasTicket() {  
        return ticket != null;  
    }  
      
    public void setTicket(Ticket ticket) {  
        this.ticket = ticket;  
    }  
      
    public void minusAmount(Long amount) {  
        this.amount -= amount;  
    }  
      
    public void plusAmount(Long amount) {  
        this.amount += amount;  
    }  
}
```
- 관람객이 소지품을 보관할 Bag 클래스
- 초대장(Invitation), 티켓(Ticket), 현금(Amount)을 인스턴스 변수로 포함
- 초대장의 보유 여부를 판단하는 `hasInvitation` 메서드와 티켓의 소유 여부를 판단하는 `hasTicket` 메서드, 현금을 증가시키거나 감소시키는 `plusAmount`와 `minusAmount` 메서드, 초대장을 티켓으로 교환하는 `setTicket` 메서드를 구현


요구사항 #3
- 이벤트에 당첨된 관람객의 가방 안에는 현금과 초대장이 들어있지만 이벤트에 당첨되지 않은 과람객의 가방 안에는 초대장이 들어있지 않을 것이다.
- 따라서 Bag 인스턴스의 상태는 현금과 초대장을 함께 보관하거나, 초대장 없이 현금만 보관하는 두 가지 중 하나일 것이다.
- Bag 인스턴스를 생성하는 시점에 이 제약을 강제할 수 있도록 생성자를 추가

Bag Class
```Java
public class Bag {
	public  Bag(Long amount) {  
	    this(null, amount);  
	}  
	  
	public Bag(Invitation invitation, Long amount) {  
	    this.invitation = invitation;  
	    this.amount = amount;  
	}

	...(생략)
}
```

Audience Class
```Java
public class Audience {  
    private Bag bag;  
  
    public Audience(Bag bag) {  
        this.bag = bag;  
    }  
  
    public Bag getBag() {  
        return bag;  
    }  
}
```
- 관람객이라는 개념을 구현
- 관람객을 소지품을 보관하기 위해 가방을 소지할 수 있음

요구사항 #4
- 관람객이 소극장에 입장하기 위해서는 매표소에서 초대장을 티켓으로 교환하거나 구매해야 함
- 따라서 매표소에는 관람객에게 판매할 티켓과 티켓의 판매 금액이 보관
- 매표소를 구현하기 위해 `TicketOffice` 클래스를 추가
- `TicketOffice`는 판매하거나 교환해 줄 티켓의 목록(tickets)과 판매 금액(amount)을 인스턴스 변수로 포함
- 티켓을 판매하는 `getTicket` 메서드는 편의를 위해 tickets 컬렉션에서 맨 첫 번째 위치에 저장된 Ticket을 반환하는 것으로 구현
- 또한 판매금액을 더하거나 차감하는 `plusAmount`와 `minusAmount` 메서드도 구현

TicketOffice Class
```Java
public class TicketOffice {  
      
    private Long amount;  
    private List<Ticket> tickets = new ArrayList<>();  
      
    public TicketOffice(Long amount, Ticket ... tickets) {  
        this.amount = amount;  
        this.tickets.addAll(Arrays.asList(tickets));  
    }  
      
    public Ticket getTicket() {  
        return tickets.remove(0);  
    }  
      
    public void minusAmount(Long amount) {  
        this.amount -= amount;  
    }  
      
    public void plusAmount(Long amount) {  
        this.amount += amount;  
    }  
}
```


TicketSeller Class
```java
public class TicketSeller {  
      
    private TicketOffice ticketOffice;  
      
    public TicketSeller(TicketOffice ticketOffice) {  
        this.ticketOffice = ticketOffice;  
    }  
      
    public TicketOffice getTicketOffice() {  
        return ticketOffice;  
    }  
}
```
- 판매원 클래스
- 매표소에서 초대장을 티켓으로 교환해 주거나 티켓을 판매하는 역할을 수행
- 판매원을 구현한 `TicketSeller` 클래스는 자신이 일하는 매표소(TicketOffice)를 알아야 함

애플리케이션 핵심 클래스 정리
![[오브젝트_1.1.png]]
- 애플리케이션 핵심 클래스 중간정리

요구사항 #5
- 소극장을 구현하는 클래스는 `Theater`
- Theater 클래스가 관람객을 맞이할 수 있도록 enter 메서드를 구현
```java
public class Theater {  
    private TicketSeller ticketSeller;  
  
    public Theater(TicketSeller ticketSeller) {  
        this.ticketSeller = ticketSeller;  
    }  
  
    public void enter(Audience audience) {  
        if (audience.getBag().hasInvitation()) {  
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();  
            audience.getBag().setTicket(ticket);  
        } else {  
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();  
            audience.getBag().minusAmount(ticket.getFee());  
            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());  
            audience.getBag().setTicket(ticket);  
        }  
    }  
}
```

위 요구사항을 구현한 코드들의 문제점

모듈의 세 가지 목적(클린 소프트웨어: 애잘일 원칙과 패턴, 그리고 실천 방법, 로버트 마틴)
> 모든 소프트웨어 모듈에는 세 가지 목적이 있다.
> 첫 번째: 실행 중에 제대로 동작하는 것
> 두 번째: 변경을 위해 존재하는 것, 대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 함, 변경하기 어려운 모듈은 제대로 동작하더라도 개선해야 함
> 세 번째: 모듈은 코드를 읽는 사람과 의사소통하는 것, 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 함


예상을 빗나가는 코드

Theater 클래스의 enter 메서드가 수행하는 일을 말로 풀었을 때
> 소극장은 관람객의 가방을 열어 그 안에 초대장이 있는지 확인, 가방에 초대장이 있으면 판매원은 매표소에 있는 티켓을 관람객의 가방으로 옮긴다. 가방 안에 초대장이 없으면 관람객의 가방에서 티켓 금액만큼의 현금을 꺼내 매표소에 적립 후 티켓을 관람객의 가방에 옮긴다.
- 위의 예시에서 발생하는 문제점: `관람객과 판매원이 소극장의 통제를 받는 수동적인 존재`
- 관람객의 입장에서 소극장이라는 제 3자가 초대장을 확인하기 위해 관람객의 가방을 마음대로 열어봄
- 판매원 역시 소극장이 매표소에 보관 중인 티켓과 현금에 마음대로 접근함
- 또한, 티켓을 꺼내 관람객의 가방에 집어넣고 관람객의 돈을 적립하는 일을 판매원이 아닌 소극장이 수행함

이해가능한 코드란?
- 우리의 예상에서 크게 벗어나지 않는 코드
- 앞에서 제시한 코드는 우리의 예상을 벗어나는 코드
- 현실에서는 관람객이 직접 자신의 가방에서 초대장을 꺼내 판매원에게 건넨다.
- 판매원은 매표소에 있는 티켓을 직접 꺼내 관람객에게 건네고 관람객에서 돈을 받아 매표소에 보관

코드를 이해하기 어렵게 만드는 또 다른 이유
- 제시한 코드를 이해하기 위해서 많은 내용을 알고 있어야 한다.
- 가령, `Theater`의 `enter` 메서드를 이해하기 위해서는 `Audience`가 `Bag`을 가지고 있고, `Bag`안에는 현금과 티켓이 들어 있으며, `TicketSeller`가 `TicketOffice`에서 티켓을 판매한다는 사실 등을 모두 알아야 한다.

가장 심각한 문제는?
- Audience나 TicketSeller에 변경이 생긴 경우 Theater도 함께 수정해야 한다.


변경에 취약한 코드
- 관람객이 가방을 들고 있지 않다면?
- 관람객이 현금 대신 카드를 들고 있다면?
- 판매원이 매표소 밖에서 티켓을 판매한다면?
- 변경에 취약하다는 것은 == 객체 사이의 의존성(dependency)이 심하다는 뜻
- 객체사이의 의존성을 완전히 없애는 것이 정답인가 ? **X**
	- 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것
	- 객체지향 설계의 목표는 애플리케이션 기능을 구현하며 필요한 최소한의 의존성만 유지하고 불필요한 의존성은 제거하는 것
- 객체 사이의 의존성이 과한 것 == 결합도(coupling)가 높은 것


설계 개선하기
- 앞선 코드의 개선 방법
	- Theater가 Audience와 TicketSeller에 관해 너무 의존성을 갖지 않도록 하기
	- Theater는 관람객이 소극장에 입장하는 것만 신경쓸 수 있도록 코드 수정
	- 관람객이 가방 안의 현금과 초대장을 처리할 수 있도록 코드 수정
	- 판매원이 스스로 매표소의 티켓과 판매 요금을 다룰 수 있도록 코드 수정
	- 즉, 관람객과 판매원을 **자율적인 존재**로 만듦

자율성을 높이기

Theater의 enter 메서드에서 TicketOffice에 접근하는 모든 코드를 TicketSeller 내부로 숨기기
```java
public class TicketSeller {  
  
    private TicketOffice ticketOffice;  
  
    public TicketSeller(TicketOffice ticketOffice) {  
        this.ticketOffice = ticketOffice;  
    }  
  
    public void sellTo(Audience audience) {  
        if (audience.getBag().hasInvitation()) {  
            Ticket ticket = ticketOffice.getTicket();  
            audience.getBag().setTicket(ticket);  
        } else {  
            Ticket ticket = ticketOffice.getTicket();  
            audience.getBag().minusAmount(ticket.getFee());  
            ticketOffice.plusAmount(ticket.getFee());  
            audience.getBag().setTicket(ticket);  
        }  
    }  
}


public class Theater {  
    private TicketSeller ticketSeller;  
  
    public Theater(TicketSeller ticketSeller) {  
        this.ticketSeller = ticketSeller;  
    }  
  
    public void enter(Audience audience) {  
        ticketSeller.sellTo(audience);  
    }  
}
```
- `TicketSeller` 클래스에서 ticketOffice의 가시성은 `private`이고 접근 가능한 퍼블릭 메서드가 사라졌다.(getTicketOffice)
- 결과적으로 ticketOffice에 대한 접근은 오직 `TicketSeller`안에만 존재하게 된다.
- 이처럼 개념적이나 물리적으로 객체 내부의 세부사항을 감추는 것을 캡슐화(capsulation)라 한다.
- 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다.
- 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있다.
- 수정된 Theater 클래스 어디에서도 ticketOffice에 접근하지 않게 수정되었다.
- 즉, Theater는 ticketOffice가 TicketSeller 내부에 존재한다는 사실을 알지 못한다.
- Theater는 오직 ticketSeller의 `인터페이스(Interface)`에만 의존한다.
- TicketSeller가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 `구현(implementation)`의 영역에 속한다.
- 객체를 인터페이스와 구현으로 나누고, 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.


수정 후 클래스 사이의 의존도
![[오브젝트_1.4.png]]


Audience의 캡슐화를 개선
- TicketSeller는 audience의 getBag 메서드를 호출해서 Audience 내부의 Bag 인스턴스에 직접 접근
- Bag 인스턴스에 접근하는 객체가 Theater에서 TicketSeller로 바뀌었을 뿐 Audience는 여전히 자율적인 존재가 아니다.
```java
public class TicketSeller {  
  
    private TicketOffice ticketOffice;  
  
    public TicketSeller(TicketOffice ticketOffice) {  
        this.ticketOffice = ticketOffice;  
    }  
  
    public void sellTo(Audience audience) {  
        ticketOffice.plusAmount(audience.buy(ticketOffice.getTicket()));  
    }  
}

public class Audience {  
    private Bag bag;  
  
    public Audience(Bag bag) {  
        this.bag = bag;  
    }  
  
    public Long buy(Ticket ticket) {  
        if (bag.hasInvitation()) {  
            bag.setTicket(ticket);  
            return 0L;  
        } else {  
            bag.setTicket(ticket);  
            bag.minusAmount(ticket.getFee());  
            return ticket.getFee();  
        }  
    }  
}
```
- TicketSeller와 Audience 사이의 결합도가 낮아짐
- 내부 구현이 캡슐화됐으므로 `Audience`의 구현을 수정하더라도 `TicketSeller`에는 영향을 미치지 않는다.
- 수정된 다이어그램 모습
![[오브젝트_1.6.png]]
- 내부 구현이 캡슐화되어 Audience의 구현을 수정해도 TicketSeller에 영향을 미치지 않는다.


Q. 내부 구현을 외부에 노출하는 코드란?
- 객체지향 프로그래밍에서 캡슐화 원칙을 위반하는 코드
- 캡슐화는 객체의 상태와 동작을 외부에서 감추는 것을 의미
- 예를 들어, `Audience` 클래스의 `getBag()`메서드는 'Bag' 객체를 직접 반환하고 있으며, `TicketSeller` 클래스의 `getTicketOffice()` 메서드도 'TicketOffice' 객체를 직접 반환함
- 이는 외부 코드에서 직접적으로 내부 객체에 접근할 수 있도록 허용함

Q. 여전히 buy라는 메서드의 구현이 바뀌는 경우가 존재할 수 있는데, Audience의 내부 구현을 의존하지 않는다는 의미는?
- 처음 로직과 달리 buy 메서드는 외부에서 'Ticket'을 전달받아 사용한다. 즉, 메서드의 동작이 외부에서 전달된 매개변수에 의존하고 있고, 외부에서 필요한 데이터를 받아오기 때문에 내부 상태에 대한 의존성이 낮아진다. 따라서 내부 구현에 덜 민감하게 설계된 방향이다.
- Audience는 Bag 내부의 내용물을 확인하거나, 추가하거나, 제거하는 작업을 스스로 처리하며, 외부의 누군가에게 자신의 가방을 열어보도록 허용하지 않도록 변경되었다. 즉, 내부 작업이 캡슐화되어 있는 상태이다.


절차지향과 객체지향
- Theater의 enter 메서드는 프로세스(Process)이며, Audience, TicketSeller, Bag, TicketOffice는 데이터(Data)이다.
- 이처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍(Procedural Programming)이라 한다.
- 일반적으로 절차적 프로그래밍은 우리의 직관에 위배된다. 절차적 프로그래밍에서 관람객과 판매원은 수동적인 존재이다.
- 더 큰 문제는 절차적 프로그래밍에서 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어렵다는 것이다.
- 절차적 프로그래밍은 프로세스가 필요한 모든 데이터를 의존해야 한다는 근본적인 문제점 때문에 변경에 취약할 수밖에 없다.
- 해결 방법은 프로세스의 적절한 단계를 Data로 이동시키는 것이다.
- 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식을 객체지향 프로그래밍(Object-Oriented Programming)이라 부른다.


책임의 이동
- 객체지향 설계에서는 독재자가 존재하지 않고, 각 객체에 책임이 적절하게 분배된다.
- 따라서 각 객체는 자신을 스스로 책임진다.

Bag 클래스 개선
- Bag을 Audience에 수동적이지 않은 자율적인 로직으로 개선
```java
public class Bag {  
    private Long amount;  
    private Invitation invitation;  
    private Ticket ticket;  
      
    public Long hold(Ticket ticket) {  
        if (hasInvitation()) {  
            setTicket(ticket);  
            return 0L;  
        } else {  
            setTicket(ticket);  
            minusAmount(ticket.getFee());  
            return ticket.getFee();  
        }  
    }  
  
    public boolean hasInvitation() {  
        return invitation != null;  
    }  
      
    public void setTicket(Ticket ticket) {  
        this.ticket = ticket;  
    }  
  
    public void minusAmount(Long amount) {  
        this.amount -= amount;  
    }  
}
```

TicketOffice 클래스 개선
```java
public class TicketOffice {  
    private Long amount;  
    private List<Ticket> tickets = new ArrayList<>();  
  
    public void sellTicketTo(Audience audience) {  
        plusAmount(audience.buy(getTicket()));  
    }  
  
    private Ticket getTicket() {  
        return tickets.remove(0);  
    }  
  
    private void plusAmount(Long amount) {  
        this.amount += amount;  
    }  
}

public class TicketSeller {  
  
    private TicketOffice ticketOffice;  
  
    public TicketSeller(TicketOffice ticketOffice) {  
        this.ticketOffice = ticketOffice;  
    }  
  
    public void sellTo(Audience audience) {  
        ticketOffice.sellTicketTo(audience);  
    }  
}
```


변경 코드의 문제점
- TicketOffice와 Audience 사이에 의존성이 추가
- 변경 전에는 TicketOffice가 Audience에 대해 알지 못했었는데, 변경 후에는 TicketOffice가 Audience에게 직접 티켓을 판매하기 때문에 의존성이 생김
- Audience에 대한 결합도와 TicketOffice의 자율성에 대한 Trade-off가 발생

의인화
- 현실에서 가방에서 돈을 꺼내는 것은 관람객이지 가방이 아니다.
- 소극장에 관람객이 입장하기 위해서도 누군가 소극장의 문을 열고 입장 허가를 해줘야 한다.
- 비록, 현실에서는 수동적인 존재라 하더라도 객체지향 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다.
- 레베카 워프스브룩은 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 가리켜 의인화(anthropomorphism)이라 부른다.


좋은 설계란 무엇인가?
- 우리가 짜는 프로그램은 두 가지 요구사항을 만족시켜야 한다.
- 기능을 구현하는 코드를 짜기 + 내일 쉽게 변경할 수 있는 코드를 짜기


Q. TicketOffice 개선하는 방법
- SOLID 5원칙 중 DIP(Dependency Inversion Principle)
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 의미
- 다음과 같은 Audience에 대한 인터페이스를 만들어 관리
```java
public interface Customer {
    Long buy(Ticket ticket);
}

public class Audience implements Customer {
    // Audience 클래스의 내용은 그대로 유지
}

public class TicketOffice {
    private Long amount;
    private List<Ticket> tickets = new ArrayList<>();

    public Long sellTicketTo(Customer customer) {
        return plusAmount(customer.buy(getTicket()));
    }

    private Ticket getTicket() {
        return tickets.remove(0);
    }

    private Long plusAmount(Long amount) {
        this.amount += amount;
        return this.amount;
    }
}

public class TicketSeller {

    private TicketOffice ticketOffice;

    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public void sellTo(Customer customer) {
        ticketOffice.sellTicketTo(customer);
    }
}

```


영화 예매 시스템 구현

요구사항 #1
- 사용자는 영화 예매 시스템으로 영화를 예매
- '영화'는 영화에 대한 기본 정보를 표현한다. 제목, 상영시간, 가격 정보와 같이 영화가 가진 기본적인 정보를 가리킨다.
- '상영'은 실제로 관객들이 영화를 관람하는 사건을 표현
- 사용자가 실제로 예매하는 대상은 영화가 아니라 상영
- 특정한 조건을 만족하는 예매자는 요금을 할인받을 수 있음
- 할인액을 결정하는 두 가지 규칙이 존재
	- 할인조건(discount condition)
	- 할인 정책(discount policy)
- 할인 조건은 가격의 할인 여부를 결정하며, '순서 조건'과 '기간 조건'의 두 종류로 나뉨
- 순서 조건은 상영 순번을 이용해 할인 여부를 결정하는 규칙
- 기간 조건은 영화 상영 시간을 이용해 할인 여부를 결정
- 할인 정책은 할인 요금을 결정
- 할인 정책에는 '금액 할인 정책'과 '비율 할인 정책'이 있다.
- 금액 할인 정책은 예매 요금에서 일정 금액을 할인해주는 방식
- 비율 할인 정책은 정가에서 일정 비율의 요금을 할인해주는 방식
- 영화별로 하나의 할인 정책만 할당할 수 있고, 할인 정책을 지정하지 않는 것도 가능하다.
- 할인 조건은 다수의 할인 조건을 함께 지정할 수 있으며, 순서 조건과 기간 조건을 섞는 것도 가능하다.
- 할인을 적용하기 위해서는 할인 조건과 할인 정책을 함께 조합해서 사용
- 할인 조건을 만족하는지 먼저 확인하고 할인 조건을 만족할 경우 할인 정책을 이용해 할인 요금을 계산


어떤 클래스가 필요한가?
- 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민
- 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것
- 객체는 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 생각
- 객체는 홀로 존재하는 것이 아니다.

도메인(domain)
- 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라 한다.
![[영화예매도메인.png]]
- 영화 예매 도메인의 예시
- 일반적으로 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 유사하게 지어야 한다.


상영 클래스 구현
```java
public class Screening {  
    private Movie movie;  
    private int sequence;  
    private LocalDateTime whenScreened;  
      
    public Screening(Movie movie, int sequence, LocalDateTime whenScreened) {  
        this.movie = movie;  
        this.sequence = sequence;  
        this.whenScreened = whenScreened;  
    }  
      
    public LocalDateTime getStartTime() {  
        return whenScreened;  
    }  
      
    public boolean isSequence(int sequence) {  
        return this.sequence == sequence;  
    }  
      
    public Money getMovieFee() {  
        return movie.getFee();  
    }  
}
```
- 인스턴스 변수의 가시성은 private
- 메서드의 가시성은 public
- 외부에서는 객체의 속성에 직접 접근할 수 없도록 막고 적절한 public 메서드를 통해서만 내부 상태를 변경해야 한다.

자율적인 객체
- 객체는 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재이다.
- 객체는 스스로 판단하고 행동하는 자율적인 존재이다.
- 객체 안에 데이터와 기능을 함께 묶는 것을 캡슐화라고 부른다.
- 캡슐화에서 나아가, 외부에서 접근을 통제할 수 있는 접근제어(access control) 메커니즘도 함께 제공한다.
- 객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다.
- 객체가 자율적인 존재로 존재하기 위해서는 외부의 간섭을 최소화해야 한다.
- 외부에서는 객체가 어떤 상태에 놓여 있는지, 어떤 생각을 하고 있는지 알아선 안 된다.


캡슐화와 접근 제어
- 퍼블릭 인터페이스(public interface): 외부에서 접근 가능한 부분 
- 구현(implementation): 외부에서는 접근이 불가능하고 오직 내부에서만 접근 가능한 부분


협력
- 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청(request)
- 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답(response)
- 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것
- 다른 객체에게 요청이 돛



출처: 오브젝트

연결문서
