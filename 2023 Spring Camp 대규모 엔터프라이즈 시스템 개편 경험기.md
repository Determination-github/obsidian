# 2023 Spring Camp 대규모 엔터프라이즈 시스템 개편 경험기
---

날짜: 2023-11-01
태그: #컨퍼런스
메모:

데이터베이스를 사용하는 이유
- SW 구현과 관리의 효율: 데이터의 무결성과 공유의 책임을 DB에 위임

서비스나 소프트웨어, 조직이 성장한다면?
- DB에 대한 예측비용이 증가
- 예측 비용: 2~3개의 어플리케이션을 쓸 때 테이블을 수정하면 예측 범위가 커짐
- 특이점을 넘어선 경우? -> 기술부채가 발생
	- 특이점을 알 수 있는 시그널: 유사한 필드 혹은 테이블이 추가되고 있을 때

행위 중복(코드 중복의 오해)
- 소크코드 중복 = 기술 부채이다.
- 소스코드 1개에 API가 N개인 경우?
	- ex) 이메일 유효성 검사 1개 & 이메일 입력 API 5개
- 소스코드 공유하는 것이 기술 부채가 아닐 수도 있다.

> 중복 코드를 추상화하여 끄집어내는 것은 DRY(Don't Repeat Yourself)를 사용하는 좋은 출발점이지만,
> 그것이 전부는 아닙니다.
> 
> 여러 분이 중복 코드를 피하려고 하는 것은 사실 각 기능과 요구사항을 한 번만 구현하려고 노력하는 것입니다.
> - 출처: 헤드 퍼스트

즉, 중복된 코드를 작성하지 않는다는 것?
- 행위에 집중하여 생각
- 코드에 집중하기 보다는 중복된 역할을 하는 API를 설계하지 않는 것이 중요

Refactoring vs Rewrite
- 리팩토링?
	- 최소한의 테스트 작성이 필요
	- 실행 비용, 시간, 범위 등을 예측할 수 없음

Rewrite를 다른 팀에게 설득하는 법?
- 없음
- 오로지 개발팀만의 노력으로 외부 지원없이 진행

FIG 애플리케이션
- 서비스 요구사항 달성이 목적
- 개발자 요구사항을 만족해야 함

그렇다면 언제해야 하나?
- 서비스 과제가 시작할 때
- Ex. 프로젝트


Strangler Pattern(Strangler Fig Pattern)
- Object Oriented
- Eventual Consistency
- Event Driven Architecture
- Domain Driven Design

일관성의 필요
- OO와 DDD는 소프트웨어 설계에 일관성과 맥락을 부여
- 일관성과 맥락은 추상화 기본 재료
- 추상화로부터 얻은 모델은 주요 관심사
- 모델은 소프트웨어에 단순함을 부여

인터페이스란?
> 일반적으로 인터페이스란 어떤 두 사물이 마주치는 경계 지점에서 서로 상호작용 할 수 있게 이어주는 방법이나 장치를 의미
> 출처: 객체지향의 사실과 오해

이벤트란?
> 정적인 상태에서 가시적인 상태의 변화?


인터페이스로 메시지를 교환 != 이벤트로 메시지를 전파
- 이벤트로 메시지를 전파
	- subscribe는 publisher에 대한 어떤 정보도 알아서는 안된다.

무결성과 Eventual Consistency
- 적절한 데이터 무결성 관리
- 모델, 개체(Entity) 단위의 이벤트로 데이터 무결성 유지
- 일관된 단위로 데이터의 무결성을 관리
	- 무결성을 구현하거나 관리하는 절차가 단순해짐
- 무결성 단위 내에서 느슨한 결합도
	- 빈약해진 데이터 무결성
- 구현 관리의 단순함과 무결성 강도 간의 트레이드 오프가 발생
	- 발생하는 무결성 문제는 다양하고 풍부한 이벤트로 극복


새로운 시스템으로 이동방법
1. 레거시 시스템에서 두번 쓰기
- 레거시 애플리케이션은 또 다른 클라이언트의 역할을 함
- Repository에서 새로운 애플리케이션(FIG)으로 API 콜
- FIG 애플리케이션은 또 다른 저장소 역할을 함
- 외부로부터의 요청을 받아 응답하는 역할

2. 데이터 마이그레이션
- 새로운 시스템으로 옮길 때는 'Read'부터 테스트, CUD는 나중에 진행
- 레거시 DB != FIG DB: 마이그레이션은 반복해서 일어날 수 있음

3. 레기서 시스템의 DB 읽기만 전환
- 쓰기 권한은 가장 마지막까지 남겨둬야 한다(동시성 이슈)
- 읽기 권한을 FIG 어플리케이션에서 하도록 수정


4. 발행-구독 패턴으로 레거시 DB 쓰기
- 레거시 애플리케이션에서 FIG DB로 write를 하고, FIG DB에 저장된 내용을 레거시 DB로 옮김

주의할 점
레거시와 FIG 애플리케이션이 서로 참조해선 안됨
- 시스템의 복잡도가 증가함
- FIG에 레거시만을 위한 기능이 추가되게 됨
- 서비스 요구사항과 관렪없는 구현 코드가 생김

Pub/Sub 구조
![[Pasted image 20231102223211.png]]
- 메세지 큐로 pub이 보내고 sub이 무엇을 할 지, 누구인지 알 필요 없음


최종 구현 형태
![[Pasted image 20231102223310.png]]
위와 같이 설계하는 이유
- FIG의 책임은 요구사항을 해결 => 레거시 DB 데이터 동기화는 FIG와 별개
- Mirror의 책임 = 레거시 시스템의 데이터 무결성 유지
- FIG와 Mirror, FIG와 레거시 시스템 간의 의존성이 없음


5. 레거시 시스템의 DB 쓰기 제거
- Write 권한을 가장 마지막에 제거하는 이유
	- Real-Time과 Near Real Time은 다름
	- 안정적인 Mirror를 구성하기까지 시간이 필요하다 -> 불확실성에 대한 대비
	- 데이터가 유실된다는 것은 곧 서버의 장애를 의미


공통 모듈의 불편함
공통 모듈
- 여러 API의 요청 사항을 처리하는 공통 서비스 모듈
- 장점
	- 코드 중복 제거
	- 코드 재사용 가능

공통 모듈의 불편함
- 의존성 문제 발생
	- 상호 참조하는 경우
	- 가늠하기 어려운 수정 범위
- 모호한 역할
	- 


출처:
[유튜브 강의](https://www.youtube.com/watch?v=UwAoUshVpgM)

연결문서
