## 설계 품질과 트레이드오프

객체의 상태와 책임
- 객체의 상태
	- 구현에 속함
	- 구현은 불안정하기 때문에 변하기 쉽다.
	- 상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체 인터페이스에 노출되어 캡슐화의 원칙이 무너진다.
- 객체의 책임
	- 인터페이스에 속한다.
	- 즉, 객체가 책임에 초점을 맞추면 상태를 캡슐화하여 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지한다.


캡슐화/응집도/결합도
캡슐화
- 외부에서 알 필요가 없는 부분을 감춰 대상을 단순화하는 추상화의 한 종류
- 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법

응집도
- 모듈에 포함된 내부 요소들이 연관된 정도
- 객체지향 관점에서 응집도는 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다.


결합도
 - 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도
- 어떤 모듈이 다른 모듈에 대해 꼭 필요한 지식만 알고 있다면 두 모듈은 낮은 결합도를 갖는다.


높은 응집도와 낮은 결합도를 유지해야 하는 이유?
- 높은 응집도와 낮은 결합도는 설계를 변경하기 쉽게 만들기 때문

결합도가 높아도 상관없는 경우
- 변경될 확률이 매우 적은 안정적인 모듈에 의존하는 것
- 표준 라이브러리에 포함된 모듈이나 성숙 단계에 접어든 프레임워크에 의존하는 경우


접근자와 수정자를 사용하면 캡슐화가 가능한가?
- 답: X
- 접근자와 수정자는 어떤 인스턴스 변수가 존재하는지 퍼블릭 인터페이스에 노골적으로 드러낸다.
	- 예시) getName, setName이라는 퍼블릭 인터페이스는 'name'이라는 인스턴스 변수가 있는 것을 드러냄


---
발표

캡슐화를 지키는 법
- 객체는 자신이 어떤 데이터를 가지고 있는지를 내부에 캡슐화하고 외부에 공개하지 않는다.
- 객체는 스스로의 상태를 책임져야 하며, 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다.
- 접근자와 수정자를 통해 속성을 외부로 제공하면 캡슐화를 위반하는 것이다.

접근자와 수정자가 갖는 문제점
- 수정자를 통해 객체의 상태를 변경하게 허용한다면?
- 해당 클래스에 의존하여 상태값을 변경하는 모든 코드들은 동일 수정자를 이용해 코드를 작성한다.
- 즉, 중복이 발생할 확률이 높다.
- 또한, 변경에 취약하다.
- 수정자 클래스 혹은 데이터 타입이 변경되는 경우 사용하던 모든 코드를 수정해야 한다.

```java
public class DiscountCondition {
	private DiscountConditionType type;
	private int sequence;
	private DayOfWeek dayOfWeek;
	private LocalTime startTime;
	private LocalTime endTime;

	public DiscountConditionType getType() { ... }
	public boolean isDiscountable(DayOfWeek dayOfWeek, LocalTime time) { ... }
	public boolean isDiscountable(int sequence) { ... }
}
```

> Q. 이 클래스의 문제점은 무엇인가?
- 'setType' 메서드는 없지만 'getType' 메서드를 통해 내부에 'DiscountConditionType'을 포함하고 있다는 정보를 노출하는 것
- `isDiscountable` 메서드의 시그니처를 보면 'DiscountCondition'에 속성으로 포함된 'DayOfWeek' 타입과 'LocalTime' 타입을  파라미터로 받는 것을 알 수 있다
- DiscountCondition의 속성을 변경해야 하면 isDiscountable 메서드의 파라미터를 수정하거나 해당 메서드를 사용하는 모든 클라이언트도 함께 수정해야 함


> Q. 인스턴스 변수가 포함되어 있다고 단언할 수 있는가?
> 변수의 파라미터로 받아서 메서드 내부에서 단순 활용될 수도 있지 않나?



> Q. 그렇다면 메서드 시그니처를 통해 객체 인스턴스 변수를 노출시키지 않는다면 모든 문제가 해결되나?

정답 : X
예시)
```java
public class Movie {  
    private String title;  
    private Duration runningTime;  
    private Money fee;  
    private List<DiscountCondition> discountConditions;  
      
    private MovieType movieType;  
    private Money discountAmount;  
    private double discountPercent;  
      
    public MovieType getMovieType() { ... }  
    public Money calculateAmountDiscountedFee() { ... }  
    public Money calculatePercentDiscountedFee() { ... }  
    public Money calculateNoneDiscountedFee() { ... }
```
 - 위 'Movie' 클래스는 메서드 시그니처나 반환 값으로 내부에 포함된 속성에 대한 어떤 정보도 노출하지 않는다.
- 그렇다면 캡슐화의 원칙을 지키고 있는 것일까? X
- 위 클래스는 할인 정책의 종류를 노출한다.
- 'calculateAmountDiscountedFee', 'calculatePercentDiscountedFee', 'calculateNoneDiscountedFee' 세 개의 메서드는 할인 정책에 세 가지 정책이 존재한다는 사실을 드러낸다.
- 만약 새로운 할인 정책이 추가되거나 제거된다면 이 메서드에 의존하는 모든 클라이언트가 영향을 받게 된다.
- 따라서 Movie는 세 가지 할인 정책을 포함하고 있다는 내부 구현을 성공적으로 캡슐화하지 못한다.


캡슐화의 진정한 의미
-  캡슐화는 단순히 객체 내부의 데이터를 외부로부터 감추는 것 이상의 의미를 갖는다.
- 캡슐화는 변경될 수 있는 어떤 것이라도 감추는 것을 의미한다. 내부 속성을 외부로부터 감추는 것은 '데이터 캡슐화'라고 불리는 캡슐화의 한 종류이다.
- 내부 구현의 변경으로 인해 외부의 객체가 영향을 받는다면 캡슐화를 위반하는 것
- 설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화해야 한다.


데이터 중심 설계의 문제점
- 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다.
- 상태란 구현이고, 구현은 변경이 가능하다.
- 데이터에 초점을 맞춘 경우 구현이 퍼블릭 인터페이스로 노출된다.(수정자/접근자)
- 혹은 데이터에 초점을 맞춘 경우 데이터에 관한 지식이 객체 인터페이스에 드러나게 된다.

정리
- 객체는 협력이라는 문맥안에서 필요한 책임을 결정하고 이를 수행할 적절한 객체를 결정하는 것이 중요하다.
- 올바른 객체지향 설계에서 무게 중심은 항상 객체 내부가 아니라 외부에 맞춰져 있어야 한다.
- 객체가 내부에 어떤 상태를 가지고 그 상태를 어떻게 관리하는지는 부가적인 문제다.


체크리스트
1. 어떤 협력이 필요한가?
	- 어떤 메시지를 주고 받을지 결정한다.
2. 어떤 메시지가 필요한가?
	- 협력의 관점에서, 어떤 메시지를 주고 받아야 하는지 결정한다.
	- 이 과정에서 이 메시지를 담당할, 즉, 책임을 담당할 클래스를 결정한다.
	- 책임을 담당할 클래스는 메시지에 맞춰서 어떤 객체로 설계할 지 결정한다.
3. 어떤 객체가 필요한가?
	- 메시지에 따라 어떤 상태와 행동이 필요한지 고민
	- 어떤 행동이 필요한지 알면 어떤 상태가 필요한지 결정할 수 있음
	- 메시지(책임)에 맞춰 추상화된 퍼블릭 인터페이스를 제공할 수 있도록 한다.
4. 캡슐화가 잘되어 있는가?
	- 캡슐화는 다음 조건들에 의해 판단할 수 있다.
	 1. 코드 중복이 발생할 가능성이 높은가?
	 2. 메서드 시그니처나 리턴값을 통해 외부에서 내부 구현을 파악하기 쉬운가?
	 3. 제공되는 인터페이스로 객체의 구현을 파악하기 쉬운가?
	 4. 객체의 구현이 변경됐을 때 수정해야 하는 외부 코드가 많은가?
