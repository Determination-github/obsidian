# 코틀린 인 액션 9장 '제네릭스'
---

날짜: 2023-11-30
태그:
메모:

제네릭스
- 여러 종류의 데이터 타입에 대해 일반적으로 동작하도록 하는 개념
- 코드의 재사용성을 높이고, 타입 안정성을 제공

제네릭스의 장점
1. 다양한 데이터 타입 지원: 함수나 클래스를 정의할 때 특정 데이터 타입을 하드코딩하지 않고, 여러 데이터 타입을 지원할 수 있음
2. 컴파일 타임 타입 안정성 제공: 컴파일 타입에 타입 오류를 잡을 수 있음
3. 코드 재사용성 증가: 특정한 데이터 타입에 의존하지 않기 때문에
4. 컬렉션 및 데이터 구조에서 활용: 주로 컬렉션이나 데이터 구조에 활용

예시:
```java
class Box<T> {
	private T value;

	public void setValue(T value) {
		this.value = value;
	}

	public T getValue() {
		return value;
	}
}

//제네릭 메서드
public <T> T genericMethod(T[] array) {
	return array[array.length / 2];
}
```


제네릭 타입 파라미터
- 제네릭스를 사용하면 타입 파라미터(type parameter)를 받는 타입을 정의할 수 있다.
- 함수나 클래스를 선언할 때, 실제 타입이 아니라 추상적인 타입을 사용해 코드를 작성할 수 있다는 의미
- 제네릭 타입의 인스턴스를 만들려면 타입 파라미터를 구체적인 타입 인자(type argument)로 치환해야 한다.
- 예시:
```kotlin
// 제네릭 클래스 정의
class Box<T>(val value: T)

// 제네릭 함수 정의
fun <T> printValue(box: Box<T>) {
	println(box.value)
}

fun main() {
	//제네릭 클래스 인스턴스 생성
	val stringBox = Box("Hello!") //구체적인 타입 인자로 치환
	val intBox = Box(42)
}
```


> 자바와 달리 코틀린에서는 제네릭 타입의 타입 인자를 프로그래머가 명시하거나 컴파일러가 추론할 수 있어야 함. 자바는 처음에 제네릭 지원이 없었다가 제네릭을 도입했기 때문에 이전 버전과 호환을 위해 타입 인자가 없는 제네릭을 허용하지만, 코틀린은 처음부터 제네릭을 고려했기 때문에 제네릭 타입 인자를 항상 정의해야 함


제네릭 함수와 프로퍼티
- 제네릭 고차 함수 호출 책 예제:
```kotlin
val authors = listOf("A", "B")
val readers = mutableListOf<String>(...)
fun <T> List.filter(predicate: (T) -> Boolean): List<T>
>>> readers.filter { it !in authors }
```

> predicate란?
> 일반적으로 참(True) 또는 거짓(false)을 반환하는 함수를 나타낸다.
> 주로 컬렉션 필터링이나 조건에 따른 처리 등에 사용

- 제네릭 고차 함수 예제:
```kotlin
// 제네릭 고차 함수 선언
fun <T> List<T>.customForEach(action: (T) -> Unit) {
    for (item in this) {
        action(item)
    }
}

fun main() {
    // 문자열 리스트에 대한 고차 함수 사용
    val stringList = listOf("Kotlin", "Java", "Swift")
    
    stringList.customForEach { println(it) }
    
    // 정수 리스트에 대한 고차 함수 사용
    val intList = listOf(1, 2, 3, 4, 5)
    
    intList.customForEach { println(it * 2) }
}
```


제네릭 확장 프로퍼티
- 제네릭 타입의 확장 프로퍼티
- 특정 타입에 속하지 않은 새로운 프로퍼티를 추가하면서, 그 프로퍼티의 타입을 제네릭으로 지정
```kotlin
val <T> List<T>.penultimate: T
	get() = this[size - 2]
```

> 확장 프로퍼티만 제네릭하게 만들 수 있음
> 일반 프로퍼티는 타입 파라미터를 가질 수 없다. 제네릭한 일반 프로퍼티를 설정할 수 없기 때문


제네릭 클래스 선언
- 타입 파라미터를 넣은 꺽쇠 기호(<>)를 클래스 이름 뒤에 붙이면 클래스(인터페이스)를 제네릭하게 만들 수 있다.
- 제네릭 클래스를 확장하는 클래스를 정의하려면 기반 타입의 제네릭 파라미터에 대한 타입 인자를 지정해야 한다.


타입 파라미터 제약(type parameter constraint)
- 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능
- 어떤 타입을 제네릭 타읩의 타입 파라미터에 대한 상한(upper bound)으로 지정하면 그 제네릭 타입을 인스턴스화할 때 사용하는 타입 인자는 반드시 그 상한 타입이거나 그 상한 타입의 하위 타입이어야 한다.
- 상한 타입 지정은 타입 파라미터 이름 뒤에 콜론(:)을 표시하여 작성한다.
- 예시:
```kotlin
// Printable 인터페이스 정의
interface Printable {
	fun print()
}

// Box 클래스는 Printable을 구현한 클래스
class Box : Printable {
	override fun print() {
		
	}
}
```


출처:
연결문서
