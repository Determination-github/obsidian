# 코틀린 인 액션 9장 '제네릭스'
---

날짜: 2023-11-30
태그:
메모:

제네릭스
- 여러 종류의 데이터 타입에 대해 일반적으로 동작하도록 하는 개념
- 코드의 재사용성을 높이고, 타입 안정성을 제공

제네릭스의 장점
1. 다양한 데이터 타입 지원: 함수나 클래스를 정의할 때 특정 데이터 타입을 하드코딩하지 않고, 여러 데이터 타입을 지원할 수 있음
2. 컴파일 타임 타입 안정성 제공: 컴파일 타입에 타입 오류를 잡을 수 있음
3. 코드 재사용성 증가: 특정한 데이터 타입에 의존하지 않기 때문에
4. 컬렉션 및 데이터 구조에서 활용: 주로 컬렉션이나 데이터 구조에 활용

예시:
```java
class Box<T> {
	private T value;

	public void setValue(T value) {
		this.value = value;
	}

	public T getValue() {
		return value;
	}
}

//제네릭 메서드
public <T> T genericMethod(T[] array) {
	return array[array.length / 2];
}
```


제네릭 타입 파라미터
- 제네릭스를 사용하면 타입 파라미터(type parameter)를 받는 타입을 정의할 수 있다.
- 함수나 클래스를 선언할 때, 실제 타입이 아니라 추상적인 타입을 사용해 코드를 작성할 수 있다는 의미
- 제네릭 타입의 인스턴스를 만들려면 타입 파라미터를 구체적인 타입 인자(type argument)로 치환해야 한다.
- 예시:
```kotlin
// 제네릭 클래스 정의
class Box<T>(val value: T)

// 제네릭 함수 정의
fun <T> printValue(box: Box<T>) {
	println(box.value)
}

fun main() {
	//제네릭 클래스 인스턴스 생성
	val stringBox = Box("Hello!") //구체적인 타입 인자로 치환
	val intBox = Box(42)
}
```


> 자바와 달리 코틀린에서는 제네릭 타입의 타입 인자를 프로그래머가 명시하거나 컴파일러가 추론할 수 있어야 함. 자바는 처음에 제네릭 지원이 없었다가 제네릭을 도입했기 때문에 이전 버전과 호환을 위해 타입 인자가 없는 제네릭을 허용하지만, 코틀린은 처음부터 제네릭을 고려했기 때문에 제네릭 타입 인자를 항상 정의해야 함


제네릭 함수와 프로퍼티
- 제네릭 고차 함수 호출 책 예제:
```kotlin
val authors = listOf("A", "B")
val readers = mutableListOf<String>(...)
fun <T> List.filter(predicate: (T) -> Boolean): List<T>
>>> readers.filter { it !in authors }
```

> predicate란?
> 일반적으로 참(True) 또는 거짓(false)을 반환하는 함수를 나타낸다.
> 주로 컬렉션 필터링이나 조건에 따른 처리 등에 사용

- 제네릭 고차 함수 예제:
```kotlin
// 제네릭 고차 함수 선언
fun <T> List<T>.customForEach(action: (T) -> Unit) {
    for (item in this) {
        action(item)
    }
}

fun main() {
    // 문자열 리스트에 대한 고차 함수 사용
    val stringList = listOf("Kotlin", "Java", "Swift")
    
    stringList.customForEach { println(it) }
    
    // 정수 리스트에 대한 고차 함수 사용
    val intList = listOf(1, 2, 3, 4, 5)
    
    intList.customForEach { println(it * 2) }
}
```


제네릭 확장 프로퍼티
- 제네릭 타입의 확장 프로퍼티
- 특정 타입에 속하지 않은 새로운 프로퍼티를 추가하면서, 그 프로퍼티의 타입을 제네릭으로 지정
```kotlin
val <T> List<T>.penultimate: T
	get() = this[size - 2]
```

> 확장 프로퍼티만 제네릭하게 만들 수 있음
> 일반 프로퍼티는 타입 파라미터를 가질 수 없다. 제네릭한 일반 프로퍼티를 설정할 수 없기 때문


제네릭 클래스 선언
- 타입 파라미터를 넣은 꺽쇠 기호(<>)를 클래스 이름 뒤에 붙이면 클래스(인터페이스)를 제네릭하게 만들 수 있다.
- 제네릭 클래스를 확장하는 클래스를 정의하려면 기반 타입의 제네릭 파라미터에 대한 타입 인자를 지정해야 한다.


타입 파라미터 제약(type parameter constraint)
- 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능
- 어떤 타입을 제네릭 타읩의 타입 파라미터에 대한 상한(upper bound)으로 지정하면 그 제네릭 타입을 인스턴스화할 때 사용하는 타입 인자는 반드시 그 상한 타입이거나 그 상한 타입의 하위 타입이어야 한다.
- 상한 타입 지정은 타입 파라미터 이름 뒤에 콜론(:)을 표시하여 작성한다.
- 예시:
```kotlin
// Printable 인터페이스 정의
interface Printable {
	fun print()
}

// Box 클래스는 Printable을 구현한 클래스
class Box : Printable {
	override fun print() {
		println("print")
	}
}

// 함수에서 상한 타입을 사용한 예시
fun <T : Printable> printValue(value: T) {
	value.print
}
```


where 키워드
- 타입 파라미터 제약을 정의
- 타입 파라미터의 제약 목록을 정의할 수 있음
- 예시
```kotlin
// Printable 인터페이스 정의
interface Printable {
    fun print()
}

// Box 클래스는 Printable을 구현한 클래스
class Box : Printable {
    override fun print() {
        println("Printing a box")
    }
}

// 함수에서 where를 사용한 예시
fun <T> printValue(value: T) where T : Printable, T : CharSequence {
    value.print()
    println("Length: ${value.length}")
}

fun main() {
    val box = Box()
    val text = "Hello, Kotlin!"

    printValue(box) // 출력: Printing a box, Length: 5

    // 아래 코드는 컴파일 에러를 발생시킴
    // printValue(text)
}
```


타입 파라미터를 널이 될 수 없는 타입으로 한정
- 아무런 상한을 정하지 않은 타입 파라미터는 결과적으로 Any?를 상한으로 정한 파라미터와 같다.
- 예시:
```kotlin
class Processor<T> {
	fun process(value: T) {
		value?.hashCode()
	}
}
```
- value는 널이 될 수 있어서 안전한 호출(?)을 사용해야 한다.
- 위의 예시를 사용해 널이 될 수 있는 타입을 사용해 인스턴스화한 예시:
```kotlin
val nullableStringProcessor = Processor<String?>()
nullableStringProcessor.process(null)
```
- 널 가능성을 제외한 아무런 제약도 없다면 `Any`를 상한으로 사용해야 함
- 예시:
```kotlin
class Processor<T: Any> {
	fun process(value: T) {
		value.hashCode()qqqœq
	}
}
```


타입 소거(type erasure)
- 제네릭 타입에 대한 정보를 컴파일 시간에만 유지하고,, 런타임에서는 실제 타입 정보를 지우는 프로세스
- 예시:
```java
public class Box<T> {
	private T value;

	public void setValue(T value) {
		this.value = value;
	}

	public T getVale() {
		return value;
	}
}
```
- 컴파일된 바이트 코드에서는 다음과 같이 변환
```java
public class Box {
	private Object value;

	public void setValue(Object value) {
		this.value = value;
	}

	public Object getValue() {
		return value;
	}
}
```
- 컴파일 시에 'Box<\T>'의 'T'는 `Object`로 치환되고, 런타임에서는 제네릭 타입 'T'에 대한 정보가 소거되므로 'Box' 클래스 내부에서는 실제 타입을 알 수 없다.

코틀린에서 제네릭
- 자바와 마찬가지로 코틀린 제네릭 타입 인자 정보는 런타임에 지워짐
- 코틀린에서 실행시점에 객체의 타입 정보는 소거된다.
- 예시:
```kotlin
fun main() {
    val stringList: List<String> = listOf("Hello", "Kotlin")

    // 실행 시점에는 List<String>이 아닌 그냥 List로만 인식됨
    val runtimeType = stringList.javaClass

    println(runtimeType)  // 출력: class java.util.Arrays$ArrayList
}
```
- runtimeType을 출력해보면 List타입만 남아있고, 원소 타입인 'String'에 대한 정보는 얻을 수 없다.
- 코틀린에서는 컴파일러가 컴파일 시에 타입 검사를 수행하므로, 실행 시점에선 제네릭 타입의 정보를 알지 못해도 컴파일 시에는 타입 안전성을 유지할 수 있다.

스타 프로젝션(Stra Projection)
- 타입 인자를 알 수 없는 상태에서, 제네릭 클래스 또는 함수를 사용할 때 유용한 기능
- 모든 타입 인자를 무시하고, 제네릭 타입을 '알 수 없는 타입'으로 취급한다.
- '\*'기호를 사용해 나타내고 주로 제네릭 클래스의 인스턴스를 생성하거나 제네릭 함수를 호출할 때 사용
```kotlin
class Box<T>(val value: T)

//스타 프로젝션을 사용한 Box인스턴스 생성
val box: Box<*> = Box("Hello")
```
- 이렇게 하면 'Box' 클래스의 모든 타입 인자를 무시하고, 그냥 'Box' 자체를 나타내는 타입의 변수를 만들 수 있다.
- 스타 프로젝션은 주로 제네릭 타입을 다룰 때 타입 정보를 알 수 없는 경우 유용하다.


실체화한 타입 파라미터를 사용한 함수 선언
- 인라인 함수의 타입 파라미터는 실체화되므로 실행 시점에 인라인 함수의 타입 인자를 알 수 있다.

reified
- 주로 인라인 함수에서 사용
- 'reified' 키워드를 사용하면 함수 내에서 제네릭 타입의 실제 정보를 런타임에 유지할 수 있다.
- 'reified'를 사용하면 인라인 함수의 컨텍스트에서 실제 타입을 유지할 수 있다.
```kotlin
// 일반적인 제네릭 함수
fun <T> exampleFunction(value: T) {
	// T에 대한 어떤 정보도 런타임에는 없음
}

// reified를 사용한 인라인 함수
inline fun <reified T> exampleInlineFunction(value: T) {
	// T에 대한 정보를 런타임에 유지
}
```


실체화한 타입 파라미터로 클래스 참조 대신
- 실체화한(reified) 타입 파라미터를 사용하는 겨우, 주로 함수에서 해당 타입에 대한 런타임 정보를 유지하고 활용하기 위해 사용
- 제네릭한 함수를 작성할 때 컴파일러가 타입 정보를 유지하도록 하는 것이 가능하다.
- 예시:
```kotlin
inline fun <reified T> printTypeName() {
    val typeName = T::class.simpleName
    println("Type name: $typeName")
}

fun main() {
    printTypeName<String>()  // Type name: String
    printTypeName<Int>()     // Type name: Int
    printTypeName<Double>()  // Type name: Double
}
```
- 클래스 참조를 직접 사용하지 않고 런타임에 타입 정보를 활용하는 방법

실체화한 타입 파라미터 제약
- 인라인 함수: `reified`키워드를 사용하려면 함수가 `inline`으로 선언되어 있어야 함
- 클래스 멤버 함수 제약: 클래스 멤버 함수에 `reified`를 사용할 수 없다.
- 프로퍼티 제약: `reified`는 프로퍼티에서 사용할 수 없다.
- 널: `reified`를 사용하는 경우 타입 파라미터는 null이 될 수 없다.


변성: 제네릭과 하위 타입

변성(variance)
- 제네릭에서 하위 타입 관계(Subtyping)가 어떻게 적용되는지를 나타내는 개념
- List<\String>과 List<\Any>와 같이 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념
- 변성에는 공변성(Covariance), 반변성(Contravariance), 무변성(Invariance)이 있다.

변성이 있는 이유: 인자를 함수에 넘기기
예시코드:
```kotlin
fun printContents(list: List<Any>) {
	println(list.joinToString())
}
```
- 위와 같은 코드는 아래와 같이 문자열 리스트를 전달해도 잘 동작한다.
```kotlin
printContents(listOf("abc", "bac"))
```
- 위 함수는 각 원소를 Any로 취급하며 모든 문자열을 Any 타입이기도 하므로 완전히 안전하다.
- 이제 리스트를 변경하는 다른 함수를 보자:
```kotlin
fun addAnswer(list: MutableList<Any>) {
	list.add(42)
}

fun main() {
    var strings = mutableListOf("abc", "bac")
    addAnswer(strings)
}
```
- 위 함수에 문자열 리스트를 넘기면 어떻게 될까?
- 출력결과 : `Type mismatch: inferred type is MutableList<String> but MutableList<Any> was expected`
- 위 코드에서 `addAnswer` 함수는 `MutableList<Any>`을 매개변수로 받고, 이 리스트에 정수를 추가한다.
- 그런데 `strings` 변수는 `MutableList<String>` 타입이므로, `addAnswer(strings)`호출이 컴파일러에서 허용되지 않는다.
- 컴파일러는 제네릭 타입에서 변성에 따라 다른 타입 간의 호환성을 결정한다.
- `MutableList<Any>`는 `MutableList<String>`의 상위 타입이 아니기 때문에 `MutableList<Any>`에 문자열을 추가할 수 없다.
- 반대로, List는 코틀린에서 공변적으로 정의되어 있다.
	- 즉, 만약 `A`가 `B`의 하위타입이라면, `List<A>`






출처:
연결문서
